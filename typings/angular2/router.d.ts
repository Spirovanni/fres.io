// Generated by dts-bundle v0.4.3
// Dependencies for this module:
//   ../../angular2/core
//   ../../angular2/src/router/router_providers_common
//   ../../angular2/src/router/router_providers
//   ../../angular2/src/facade/lang

declare module 'angular2/router' {
    /**
        * @module
        * @description
        * Maps application URLs into application states, to support deep-linking and navigation.
        */
    export { Router } from 'angular2/router/src/router/router';
    export { RouterOutlet } from 'angular2/router/src/router/directives/router_outlet';
    export { RouterLink } from 'angular2/router/src/router/directives/router_link';
    export { RouteParams, RouteData } from 'angular2/router/src/router/instruction';
    export { PlatformLocation } from 'angular2/router/src/router/location/platform_location';
    export { RouteRegistry, ROUTER_PRIMARY_COMPONENT } from 'angular2/router/src/router/route_registry';
    export { LocationStrategy, APP_BASE_HREF } from 'angular2/router/src/router/location/location_strategy';
    export { HashLocationStrategy } from 'angular2/router/src/router/location/hash_location_strategy';
    export { PathLocationStrategy } from 'angular2/router/src/router/location/path_location_strategy';
    export { Location } from 'angular2/router/src/router/location/location';
    export * from 'angular2/router/src/router/route_config/route_config_decorator';
    export * from 'angular2/router/src/router/route_definition';
    export { OnActivate, OnDeactivate, OnReuse, CanDeactivate, CanReuse } from 'angular2/router/src/router/interfaces';
    export { CanActivate } from 'angular2/router/src/router/lifecycle/lifecycle_annotations';
    export { Instruction, ComponentInstruction } from 'angular2/router/src/router/instruction';
    export { OpaqueToken } from 'angular2/core';
    export { ROUTER_PROVIDERS_COMMON } from 'angular2/src/router/router_providers_common';
    export { ROUTER_PROVIDERS, ROUTER_BINDINGS } from 'angular2/src/router/router_providers';
    /**
        * A list of directives. To use the router directives like {@link RouterOutlet} and
        * {@link RouterLink}, add this to your `directives` array in the {@link View} decorator of your
        * component.
        *
        * ### Example ([live demo](http://plnkr.co/edit/iRUP8B5OUbxCWQ3AcIDm))
        *
        * ```
        * import {Component} from 'angular2/core';
        * import {ROUTER_DIRECTIVES, ROUTER_PROVIDERS, RouteConfig} from 'angular2/router';
        *
        * @Component({directives: [ROUTER_DIRECTIVES]})
        * @RouteConfig([
        *  {...},
        * ])
        * class AppCmp {
        *    // ...
        * }
        *
        * bootstrap(AppCmp, [ROUTER_PROVIDERS]);
        * ```
        */
    export const ROUTER_DIRECTIVES: any[];
}

declare module 'angular2/router/src/router/router' {
    import { Type } from 'angular2/src/facade/lang';
    import { RouteRegistry } from 'angular2/router/src/router/route_registry';
    import { Instruction } from 'angular2/router/src/router/instruction';
    import { RouterOutlet } from 'angular2/router/src/router/directives/router_outlet';
    import { Location } from 'angular2/router/src/router/location/location';
    import { RouteDefinition } from 'angular2/router/src/router/route_config/route_config_impl';
    /**
        * The `Router` is responsible for mapping URLs to components.
        *
        * You can see the state of the router by inspecting the read-only field `router.navigating`.
        * This may be useful for showing a spinner, for instance.
        *
        * ## Concepts
        *
        * Routers and component instances have a 1:1 correspondence.
        *
        * The router holds reference to a number of {@link RouterOutlet}.
        * An outlet is a placeholder that the router dynamically fills in depending on the current URL.
        *
        * When the router navigates from a URL, it must first recognize it and serialize it into an
        * `Instruction`.
        * The router uses the `RouteRegistry` to get an `Instruction`.
        */
    export class Router {
            registry: RouteRegistry;
            parent: Router;
            hostComponent: any;
            root: Router;
            navigating: boolean;
            lastNavigationAttempt: string;
            /**
                * The current `Instruction` for the router
                */
            currentInstruction: Instruction;
            constructor(registry: RouteRegistry, parent: Router, hostComponent: any, root?: Router);
            /**
                * Constructs a child router. You probably don't need to use this unless you're writing a reusable
                * component.
                */
            childRouter(hostComponent: any): Router;
            /**
                * Constructs a child router. You probably don't need to use this unless you're writing a reusable
                * component.
                */
            auxRouter(hostComponent: any): Router;
            /**
                * Register an outlet to be notified of primary route changes.
                *
                * You probably don't need to use this unless you're writing a reusable component.
                */
            registerPrimaryOutlet(outlet: RouterOutlet): Promise<boolean>;
            /**
                * Unregister an outlet (because it was destroyed, etc).
                *
                * You probably don't need to use this unless you're writing a custom outlet implementation.
                */
            unregisterPrimaryOutlet(outlet: RouterOutlet): void;
            /**
                * Register an outlet to notified of auxiliary route changes.
                *
                * You probably don't need to use this unless you're writing a reusable component.
                */
            registerAuxOutlet(outlet: RouterOutlet): Promise<boolean>;
            /**
                * Given an instruction, returns `true` if the instruction is currently active,
                * otherwise `false`.
                */
            isRouteActive(instruction: Instruction): boolean;
            /**
                * Dynamically update the routing configuration and trigger a navigation.
                *
                * ### Usage
                *
                * ```
                * router.config([
                *   { 'path': '/', 'component': IndexComp },
                *   { 'path': '/user/:id', 'component': UserComp },
                * ]);
                * ```
                */
            config(definitions: RouteDefinition[]): Promise<any>;
            /**
                * Navigate based on the provided Route Link DSL. It's preferred to navigate with this method
                * over `navigateByUrl`.
                *
                * ### Usage
                *
                * This method takes an array representing the Route Link DSL:
                * ```
                * ['./MyCmp', {param: 3}]
                * ```
                * See the {@link RouterLink} directive for more.
                */
            navigate(linkParams: any[]): Promise<any>;
            /**
                * Navigate to a URL. Returns a promise that resolves when navigation is complete.
                * It's preferred to navigate with `navigate` instead of this method, since URLs are more brittle.
                *
                * If the given URL begins with a `/`, router will navigate absolutely.
                * If the given URL does not begin with `/`, the router will navigate relative to this component.
                */
            navigateByUrl(url: string, _skipLocationChange?: boolean): Promise<any>;
            /**
                * Navigate via the provided instruction. Returns a promise that resolves when navigation is
                * complete.
                */
            navigateByInstruction(instruction: Instruction, _skipLocationChange?: boolean): Promise<any>;
            /**
                * Updates this router and all descendant routers according to the given instruction
                */
            commit(instruction: Instruction, _skipLocationChange?: boolean): Promise<any>;
            /**
                * Subscribe to URL updates from the router
                */
            subscribe(onNext: (value: any) => void): Object;
            /**
                * Removes the contents of this router's outlet and all descendant outlets
                */
            deactivate(instruction: Instruction): Promise<any>;
            /**
                * Given a URL, returns an instruction representing the component graph
                */
            recognize(url: string): Promise<Instruction>;
            /**
                * Navigates to either the last URL successfully navigated to, or the last URL requested if the
                * router has yet to successfully navigate.
                */
            renavigate(): Promise<any>;
            /**
                * Generate an `Instruction` based on the provided Route Link DSL.
                */
            generate(linkParams: any[]): Instruction;
    }
    export class RootRouter extends Router {
            constructor(registry: RouteRegistry, location: Location, primaryComponent: Type);
            commit(instruction: Instruction, _skipLocationChange?: boolean): Promise<any>;
            dispose(): void;
    }
}

declare module 'angular2/router/src/router/directives/router_outlet' {
    import { DynamicComponentLoader, ElementRef, OnDestroy } from 'angular2/core';
    import * as routerMod from 'angular2/router/src/router/router';
    import { ComponentInstruction } from 'angular2/router/src/router/instruction';
    /**
        * A router outlet is a placeholder that Angular dynamically fills based on the application's route.
        *
        * ## Use
        *
        * ```
        * <router-outlet></router-outlet>
        * ```
        */
    export class RouterOutlet implements OnDestroy {
            name: string;
            constructor(_elementRef: ElementRef, _loader: DynamicComponentLoader, _parentRouter: routerMod.Router, nameAttr: string);
            /**
                * Called by the Router to instantiate a new component during the commit phase of a navigation.
                * This method in turn is responsible for calling the `routerOnActivate` hook of its child.
                */
            activate(nextInstruction: ComponentInstruction): Promise<any>;
            /**
                * Called by the {@link Router} during the commit phase of a navigation when an outlet
                * reuses a component between different routes.
                * This method in turn is responsible for calling the `routerOnReuse` hook of its child.
                */
            reuse(nextInstruction: ComponentInstruction): Promise<any>;
            /**
                * Called by the {@link Router} when an outlet disposes of a component's contents.
                * This method in turn is responsible for calling the `routerOnDeactivate` hook of its child.
                */
            deactivate(nextInstruction: ComponentInstruction): Promise<any>;
            /**
                * Called by the {@link Router} during recognition phase of a navigation.
                *
                * If this resolves to `false`, the given navigation is cancelled.
                *
                * This method delegates to the child component's `routerCanDeactivate` hook if it exists,
                * and otherwise resolves to true.
                */
            routerCanDeactivate(nextInstruction: ComponentInstruction): Promise<boolean>;
            /**
                * Called by the {@link Router} during recognition phase of a navigation.
                *
                * If the new child component has a different Type than the existing child component,
                * this will resolve to `false`. You can't reuse an old component when the new component
                * is of a different Type.
                *
                * Otherwise, this method delegates to the child component's `routerCanReuse` hook if it exists,
                * or resolves to true if the hook is not present.
                */
            routerCanReuse(nextInstruction: ComponentInstruction): Promise<boolean>;
            ngOnDestroy(): void;
    }
}

declare module 'angular2/router/src/router/directives/router_link' {
    import { Router } from 'angular2/router/src/router/router';
    import { Location } from 'angular2/router/src/router/location/location';
    /**
      * The RouterLink directive lets you link to specific parts of your app.
      *
      * Consider the following route configuration:
    
      * ```
      * @RouteConfig([
      *   { path: '/user', component: UserCmp, as: 'User' }
      * ]);
      * class MyComp {}
      * ```
      *
      * When linking to this `User` route, you can write:
      *
      * ```
      * <a [routerLink]="['./User']">link to user component</a>
      * ```
      *
      * RouterLink expects the value to be an array of route names, followed by the params
      * for that level of routing. For instance `['/Team', {teamId: 1}, 'User', {userId: 2}]`
      * means that we want to generate a link for the `Team` route with params `{teamId: 1}`,
      * and with a child route `User` with params `{userId: 2}`.
      *
      * The first route name should be prepended with `/`, `./`, or `../`.
      * If the route begins with `/`, the router will look up the route from the root of the app.
      * If the route begins with `./`, the router will instead look in the current component's
      * children for the route. And if the route begins with `../`, the router will look at the
      * current component's parent.
      */
    export class RouterLink {
        visibleHref: string;
        target: string;
        constructor(_router: Router, _location: Location);
        isRouteActive: boolean;
        routeParams: any[];
        onClick(): boolean;
    }
}

declare module 'angular2/router/src/router/instruction' {
    /**
        * `RouteParams` is an immutable map of parameters for the given route
        * based on the url matcher and optional parameters for that route.
        *
        * You can inject `RouteParams` into the constructor of a component to use it.
        *
        * ### Example
        *
        * ```
        * import {Component} from 'angular2/core';
        * import {bootstrap} from 'angular2/platform/browser';
        * import {Router, ROUTER_DIRECTIVES, ROUTER_PROVIDERS, RouteConfig, RouteParams} from
        * 'angular2/router';
        *
        * @Component({directives: [ROUTER_DIRECTIVES]})
        * @RouteConfig([
        *  {path: '/user/:id', component: UserCmp, name: 'UserCmp'},
        * ])
        * class AppCmp {}
        *
        * @Component({ template: 'user: {{id}}' })
        * class UserCmp {
        *   id: string;
        *   constructor(params: RouteParams) {
        *     this.id = params.get('id');
        *   }
        * }
        *
        * bootstrap(AppCmp, ROUTER_PROVIDERS);
        * ```
        */
    export class RouteParams {
            params: {
                    [key: string]: string;
            };
            constructor(params: {
                    [key: string]: string;
            });
            get(param: string): string;
    }
    /**
        * `RouteData` is an immutable map of additional data you can configure in your {@link Route}.
        *
        * You can inject `RouteData` into the constructor of a component to use it.
        *
        * ### Example
        *
        * ```
        * import {Component} from 'angular2/core';
        * import {bootstrap} from 'angular2/platform/browser';
        * import {Router, ROUTER_DIRECTIVES, ROUTER_PROVIDERS, RouteConfig, RouteData} from
        * 'angular2/router';
        *
        * @Component({directives: [ROUTER_DIRECTIVES]})
        * @RouteConfig([
        *  {path: '/user/:id', component: UserCmp, name: 'UserCmp', data: {isAdmin: true}},
        * ])
        * class AppCmp {}
        *
        * @Component({...})
        * @View({ template: 'user: {{isAdmin}}' })
        * class UserCmp {
        *   string: isAdmin;
        *   constructor(data: RouteData) {
        *     this.isAdmin = data.get('isAdmin');
        *   }
        * }
        *
        * bootstrap(AppCmp, ROUTER_PROVIDERS);
        * ```
        */
    export class RouteData {
            data: {
                    [key: string]: any;
            };
            constructor(data?: {
                    [key: string]: any;
            });
            get(key: string): any;
    }
    export var BLANK_ROUTE_DATA: RouteData;
    /**
        * `Instruction` is a tree of {@link ComponentInstruction}s with all the information needed
        * to transition each component in the app to a given route, including all auxiliary routes.
        *
        * `Instruction`s can be created using {@link Router#generate}, and can be used to
        * perform route changes with {@link Router#navigateByInstruction}.
        *
        * ### Example
        *
        * ```
        * import {Component} from 'angular2/core';
        * import {bootstrap} from 'angular2/platform/browser';
        * import {Router, ROUTER_DIRECTIVES, ROUTER_PROVIDERS, RouteConfig} from 'angular2/router';
        *
        * @Component({directives: [ROUTER_DIRECTIVES]})
        * @RouteConfig([
        *  {...},
        * ])
        * class AppCmp {
        *   constructor(router: Router) {
        *     var instruction = router.generate(['/MyRoute']);
        *     router.navigateByInstruction(instruction);
        *   }
        * }
        *
        * bootstrap(AppCmp, ROUTER_PROVIDERS);
        * ```
        */
    export abstract class Instruction {
            component: ComponentInstruction;
            child: Instruction;
            auxInstruction: {
                    [key: string]: Instruction;
            };
            constructor(component: ComponentInstruction, child: Instruction, auxInstruction: {
                    [key: string]: Instruction;
            });
            urlPath: string;
            urlParams: string[];
            specificity: string;
            abstract resolveComponent(): Promise<ComponentInstruction>;
            /**
                * converts the instruction into a URL string
                */
            toRootUrl(): string;
            toUrlQuery(): string;
            /**
                * Returns a new instruction that shares the state of the existing instruction, but with
                * the given child {@link Instruction} replacing the existing child.
                */
            replaceChild(child: Instruction): Instruction;
            /**
                * If the final URL for the instruction is ``
                */
            toUrlPath(): string;
            toLinkUrl(): string;
    }
    /**
        * a resolved instruction has an outlet instruction for itself, but maybe not for...
        */
    export class ResolvedInstruction extends Instruction {
            constructor(component: ComponentInstruction, child: Instruction, auxInstruction: {
                    [key: string]: Instruction;
            });
            resolveComponent(): Promise<ComponentInstruction>;
    }
    /**
        * Represents a resolved default route
        */
    export class DefaultInstruction extends ResolvedInstruction {
            constructor(component: ComponentInstruction, child: DefaultInstruction);
            toLinkUrl(): string;
    }
    /**
        * Represents a component that may need to do some redirection or lazy loading at a later time.
        */
    export class UnresolvedInstruction extends Instruction {
            constructor(_resolver: () => Promise<Instruction>, _urlPath?: string, _urlParams?: string[]);
            urlPath: string;
            urlParams: string[];
            resolveComponent(): Promise<ComponentInstruction>;
    }
    export class RedirectInstruction extends ResolvedInstruction {
            constructor(component: ComponentInstruction, child: Instruction, auxInstruction: {
                    [key: string]: Instruction;
            }, _specificity: string);
            specificity: string;
    }
    /**
        * A `ComponentInstruction` represents the route state for a single component.
        *
        * `ComponentInstructions` is a public API. Instances of `ComponentInstruction` are passed
        * to route lifecycle hooks, like {@link CanActivate}.
        *
        * `ComponentInstruction`s are [hash consed](https://en.wikipedia.org/wiki/Hash_consing). You should
        * never construct one yourself with "new." Instead, rely on {@link Router/RouteRecognizer} to
        * construct `ComponentInstruction`s.
        *
        * You should not modify this object. It should be treated as immutable.
        */
    export class ComponentInstruction {
            urlPath: string;
            urlParams: string[];
            componentType: any;
            terminal: boolean;
            specificity: string;
            params: {
                    [key: string]: any;
            };
            reuse: boolean;
            routeData: RouteData;
    }
}

declare module 'angular2/router/src/router/location/platform_location' {
    /**
        * This class should not be used directly by an application developer. Instead, use
        * {@link Location}.
        *
        * `PlatformLocation` encapsulates all calls to DOM apis, which allows the Router to be platform
        * agnostic.
        * This means that we can have different implementation of `PlatformLocation` for the different
        * platforms
        * that angular supports. For example, the default `PlatformLocation` is {@link
        * BrowserPlatformLocation},
        * however when you run your app in a WebWorker you use {@link WebWorkerPlatformLocation}.
        *
        * The `PlatformLocation` class is used directly by all implementations of {@link LocationStrategy}
        * when
        * they need to interact with the DOM apis like pushState, popState, etc...
        *
        * {@link LocationStrategy} in turn is used by the {@link Location} service which is used directly
        * by
        * the {@link Router} in order to navigate between routes. Since all interactions between {@link
        * Router} /
        * {@link Location} / {@link LocationStrategy} and DOM apis flow through the `PlatformLocation`
        * class
        * they are all platform independent.
        */
    export abstract class PlatformLocation {
            abstract getBaseHrefFromDOM(): string;
            abstract onPopState(fn: UrlChangeListener): void;
            abstract onHashChange(fn: UrlChangeListener): void;
            pathname: string;
            search: string;
            hash: string;
            abstract replaceState(state: any, title: string, url: string): void;
            abstract pushState(state: any, title: string, url: string): void;
            abstract forward(): void;
            abstract back(): void;
    }
    /**
        * A serializable version of the event from onPopState or onHashChange
        */
    export interface UrlChangeEvent {
            type: string;
    }
    export interface UrlChangeListener {
            (e: UrlChangeEvent): any;
    }
}

declare module 'angular2/router/src/router/route_registry' {
    import { Type } from 'angular2/src/facade/lang';
    import { OpaqueToken } from 'angular2/core';
    import { RouteDefinition } from 'angular2/router/src/router/route_config/route_config_impl';
    import { Instruction } from 'angular2/router/src/router/instruction';
    /**
        * Token used to bind the component with the top-level {@link RouteConfig}s for the
        * application.
        *
        * ### Example ([live demo](http://plnkr.co/edit/iRUP8B5OUbxCWQ3AcIDm))
        *
        * ```
        * import {Component} from 'angular2/core';
        * import {
        *   ROUTER_DIRECTIVES,
        *   ROUTER_PROVIDERS,
        *   RouteConfig
        * } from 'angular2/router';
        *
        * @Component({directives: [ROUTER_DIRECTIVES]})
        * @RouteConfig([
        *  {...},
        * ])
        * class AppCmp {
        *   // ...
        * }
        *
        * bootstrap(AppCmp, [ROUTER_PROVIDERS]);
        * ```
        */
    export const ROUTER_PRIMARY_COMPONENT: OpaqueToken;
    /**
        * The RouteRegistry holds route configurations for each component in an Angular app.
        * It is responsible for creating Instructions from URLs, and generating URLs based on route and
        * parameters.
        */
    export class RouteRegistry {
            constructor(_rootComponent: Type);
            /**
                * Given a component and a configuration object, add the route to this registry
                */
            config(parentComponent: any, config: RouteDefinition): void;
            /**
                * Reads the annotations of a component and configures the registry based on them
                */
            configFromComponent(component: any): void;
            /**
                * Given a URL and a parent component, return the most specific instruction for navigating
                * the application into the state specified by the url
                */
            recognize(url: string, ancestorInstructions: Instruction[]): Promise<Instruction>;
            /**
                * Given a normalized list with component names and params like: `['user', {id: 3 }]`
                * generates a url with a leading slash relative to the provided `parentComponent`.
                *
                * If the optional param `_aux` is `true`, then we generate starting at an auxiliary
                * route boundary.
                */
            generate(linkParams: any[], ancestorInstructions: Instruction[], _aux?: boolean): Instruction;
            hasRoute(name: string, parentComponent: any): boolean;
            generateDefault(componentCursor: Type): Instruction;
    }
}

declare module 'angular2/router/src/router/location/location_strategy' {
    import { OpaqueToken } from 'angular2/core';
    import { UrlChangeListener } from 'angular2/router/src/router/location/platform_location';
    /**
        * `LocationStrategy` is responsible for representing and reading route state
        * from the browser's URL. Angular provides two strategies:
        * {@link HashLocationStrategy} and {@link PathLocationStrategy} (default).
        *
        * This is used under the hood of the {@link Location} service.
        *
        * Applications should use the {@link Router} or {@link Location} services to
        * interact with application route state.
        *
        * For instance, {@link HashLocationStrategy} produces URLs like
        * `http://example.com#/foo`, and {@link PathLocationStrategy} produces
        * `http://example.com/foo` as an equivalent URL.
        *
        * See these two classes for more.
        */
    export abstract class LocationStrategy {
            abstract path(): string;
            abstract prepareExternalUrl(internal: string): string;
            abstract pushState(state: any, title: string, url: string, queryParams: string): void;
            abstract replaceState(state: any, title: string, url: string, queryParams: string): void;
            abstract forward(): void;
            abstract back(): void;
            abstract onPopState(fn: UrlChangeListener): void;
            abstract getBaseHref(): string;
    }
    /**
        * The `APP_BASE_HREF` token represents the base href to be used with the
        * {@link PathLocationStrategy}.
        *
        * If you're using {@link PathLocationStrategy}, you must provide a provider to a string
        * representing the URL prefix that should be preserved when generating and recognizing
        * URLs.
        *
        * ### Example
        *
        * ```
        * import {Component} from 'angular2/core';
        * import {ROUTER_DIRECTIVES, ROUTER_PROVIDERS, RouteConfig} from 'angular2/router';
        *
        * @Component({directives: [ROUTER_DIRECTIVES]})
        * @RouteConfig([
        *  {...},
        * ])
        * class AppCmp {
        *   // ...
        * }
        *
        * bootstrap(AppCmp, [
        *   ROUTER_PROVIDERS,
        *   provide(APP_BASE_HREF, {useValue: '/my/app'})
        * ]);
        * ```
        */
    export const APP_BASE_HREF: OpaqueToken;
    export function normalizeQueryParams(params: string): string;
    export function joinWithSlash(start: string, end: string): string;
}

declare module 'angular2/router/src/router/location/hash_location_strategy' {
    import { LocationStrategy } from 'angular2/router/src/router/location/location_strategy';
    import { UrlChangeListener } from 'angular2/router/src/router/location/platform_location';
    import { PlatformLocation } from 'angular2/router/src/router/location/platform_location';
    /**
      * `HashLocationStrategy` is a {@link LocationStrategy} used to configure the
      * {@link Location} service to represent its state in the
      * [hash fragment](https://en.wikipedia.org/wiki/Uniform_Resource_Locator#Syntax)
      * of the browser's URL.
      *
      * For instance, if you call `location.go('/foo')`, the browser's URL will become
      * `example.com#/foo`.
      *
      * ### Example
      *
      * ```
      * import {Component, provide} from 'angular2/core';
      * import {
      *   ROUTER_DIRECTIVES,
      *   ROUTER_PROVIDERS,
      *   RouteConfig,
      *   Location,
      *   LocationStrategy,
      *   HashLocationStrategy
      * } from 'angular2/router';
      *
      * @Component({directives: [ROUTER_DIRECTIVES]})
      * @RouteConfig([
      *  {...},
      * ])
      * class AppCmp {
      *   constructor(location: Location) {
      *     location.go('/foo');
      *   }
      * }
      *
      * bootstrap(AppCmp, [
      *   ROUTER_PROVIDERS,
      *   provide(LocationStrategy, {useClass: HashLocationStrategy})
      * ]);
      * ```
      */
    export class HashLocationStrategy extends LocationStrategy {
        constructor(_platformLocation: PlatformLocation, _baseHref?: string);
        onPopState(fn: UrlChangeListener): void;
        getBaseHref(): string;
        path(): string;
        prepareExternalUrl(internal: string): string;
        pushState(state: any, title: string, path: string, queryParams: string): void;
        replaceState(state: any, title: string, path: string, queryParams: string): void;
        forward(): void;
        back(): void;
    }
}

declare module 'angular2/router/src/router/location/path_location_strategy' {
    import { LocationStrategy } from 'angular2/router/src/router/location/location_strategy';
    import { PlatformLocation, UrlChangeListener } from 'angular2/router/src/router/location/platform_location';
    /**
      * `PathLocationStrategy` is a {@link LocationStrategy} used to configure the
      * {@link Location} service to represent its state in the
      * [path](https://en.wikipedia.org/wiki/Uniform_Resource_Locator#Syntax) of the
      * browser's URL.
      *
      * `PathLocationStrategy` is the default binding for {@link LocationStrategy}
      * provided in {@link ROUTER_PROVIDERS}.
      *
      * If you're using `PathLocationStrategy`, you must provide a provider for
      * {@link APP_BASE_HREF} to a string representing the URL prefix that should
      * be preserved when generating and recognizing URLs.
      *
      * For instance, if you provide an `APP_BASE_HREF` of `'/my/app'` and call
      * `location.go('/foo')`, the browser's URL will become
      * `example.com/my/app/foo`.
      *
      * ### Example
      *
      * ```
      * import {Component, provide} from 'angular2/core';
      * import {
      *   APP_BASE_HREF
      *   ROUTER_DIRECTIVES,
      *   ROUTER_PROVIDERS,
      *   RouteConfig,
      *   Location
      * } from 'angular2/router';
      *
      * @Component({directives: [ROUTER_DIRECTIVES]})
      * @RouteConfig([
      *  {...},
      * ])
      * class AppCmp {
      *   constructor(location: Location) {
      *     location.go('/foo');
      *   }
      * }
      *
      * bootstrap(AppCmp, [
      *   ROUTER_PROVIDERS, // includes binding to PathLocationStrategy
      *   provide(APP_BASE_HREF, {useValue: '/my/app'})
      * ]);
      * ```
      */
    export class PathLocationStrategy extends LocationStrategy {
        constructor(_platformLocation: PlatformLocation, href?: string);
        onPopState(fn: UrlChangeListener): void;
        getBaseHref(): string;
        prepareExternalUrl(internal: string): string;
        path(): string;
        pushState(state: any, title: string, url: string, queryParams: string): void;
        replaceState(state: any, title: string, url: string, queryParams: string): void;
        forward(): void;
        back(): void;
    }
}

declare module 'angular2/router/src/router/location/location' {
    import { LocationStrategy } from 'angular2/router/src/router/location/location_strategy';
    /**
        * `Location` is a service that applications can use to interact with a browser's URL.
        * Depending on which {@link LocationStrategy} is used, `Location` will either persist
        * to the URL's path or the URL's hash segment.
        *
        * Note: it's better to use {@link Router#navigate} service to trigger route changes. Use
        * `Location` only if you need to interact with or create normalized URLs outside of
        * routing.
        *
        * `Location` is responsible for normalizing the URL against the application's base href.
        * A normalized URL is absolute from the URL host, includes the application's base href, and has no
        * trailing slash:
        * - `/my/app/user/123` is normalized
        * - `my/app/user/123` **is not** normalized
        * - `/my/app/user/123/` **is not** normalized
        *
        * ### Example
        *
        * ```
        * import {Component} from 'angular2/core';
        * import {
        *   ROUTER_DIRECTIVES,
        *   ROUTER_PROVIDERS,
        *   RouteConfig,
        *   Location
        * } from 'angular2/router';
        *
        * @Component({directives: [ROUTER_DIRECTIVES]})
        * @RouteConfig([
        *  {...},
        * ])
        * class AppCmp {
        *   constructor(location: Location) {
        *     location.go('/foo');
        *   }
        * }
        *
        * bootstrap(AppCmp, [ROUTER_PROVIDERS]);
        * ```
        */
    export class Location {
            platformStrategy: LocationStrategy;
            constructor(platformStrategy: LocationStrategy);
            /**
                * Returns the normalized URL path.
                */
            path(): string;
            /**
                * Given a string representing a URL, returns the normalized URL path without leading or
                * trailing slashes
                */
            normalize(url: string): string;
            /**
                * Given a string representing a URL, returns the platform-specific external URL path.
                * If the given URL doesn't begin with a leading slash (`'/'`), this method adds one
                * before normalizing. This method will also add a hash if `HashLocationStrategy` is
                * used, or the `APP_BASE_HREF` if the `PathLocationStrategy` is in use.
                */
            prepareExternalUrl(url: string): string;
            /**
                * Changes the browsers URL to the normalized version of the given URL, and pushes a
                * new item onto the platform's history.
                */
            go(path: string, query?: string): void;
            /**
                * Changes the browsers URL to the normalized version of the given URL, and replaces
                * the top item on the platform's history stack.
                */
            replaceState(path: string, query?: string): void;
            /**
                * Navigates forward in the platform's history.
                */
            forward(): void;
            /**
                * Navigates back in the platform's history.
                */
            back(): void;
            /**
                * Subscribe to the platform's `popState` events.
                */
            subscribe(onNext: (value: any) => void, onThrow?: (exception: any) => void, onReturn?: () => void): Object;
    }
}

declare module 'angular2/router/src/router/route_config/route_config_decorator' {
    import { RouteDefinition } from 'angular2/router/src/router/route_config/route_config_impl';
    export { Route, Redirect, AuxRoute, AsyncRoute, RouteDefinition } from 'angular2/router/src/router/route_config/route_config_impl';
    /**
      * The `RouteConfig` decorator defines routes for a given component.
      *
      * It takes an array of {@link RouteDefinition}s.
      */
    export var RouteConfig: (configs: RouteDefinition[]) => ClassDecorator;
}

declare module 'angular2/router/src/router/route_definition' {
    import { Type } from 'angular2/src/facade/lang';
    import { RegexSerializer } from 'angular2/router/src/router/rules/route_paths/regex_route_path';
    /**
        * `RouteDefinition` defines a route within a {@link RouteConfig} decorator.
        *
        * Supported keys:
        * - `path` or `aux` (requires exactly one of these)
        * - `component`, `loader`,  `redirectTo` (requires exactly one of these)
        * - `name` or `as` (optional) (requires exactly one of these)
        * - `data` (optional)
        *
        * See also {@link Route}, {@link AsyncRoute}, {@link AuxRoute}, and {@link Redirect}.
        */
    export interface RouteDefinition {
            path?: string;
            aux?: string;
            regex?: string;
            serializer?: RegexSerializer;
            component?: Type | ComponentDefinition;
            loader?: Function;
            redirectTo?: any[];
            as?: string;
            name?: string;
            data?: any;
            useAsDefault?: boolean;
    }
    /**
        * Represents either a component type (`type` is `component`) or a loader function
        * (`type` is `loader`).
        *
        * See also {@link RouteDefinition}.
        */
    export interface ComponentDefinition {
            type: string;
            loader?: Function;
            component?: Type;
    }
}

declare module 'angular2/router/src/router/interfaces' {
    import { ComponentInstruction } from 'angular2/router/src/router/instruction';
    /**
        * Defines route lifecycle method `routerOnActivate`, which is called by the router at the end of a
        * successful route navigation.
        *
        * For a single component's navigation, only one of either {@link OnActivate} or {@link OnReuse}
        * will be called depending on the result of {@link CanReuse}.
        *
        * The `routerOnActivate` hook is called with two {@link ComponentInstruction}s as parameters, the
        * first
        * representing the current route being navigated to, and the second parameter representing the
        * previous route or `null`.
        *
        * If `routerOnActivate` returns a promise, the route change will wait until the promise settles to
        * instantiate and activate child components.
        *
        * ### Example
        * {@example router/ts/on_activate/on_activate_example.ts region='routerOnActivate'}
        */
    export interface OnActivate {
            routerOnActivate(nextInstruction: ComponentInstruction, prevInstruction: ComponentInstruction): any;
    }
    /**
        * Defines route lifecycle method `routerOnReuse`, which is called by the router at the end of a
        * successful route navigation when {@link CanReuse} is implemented and returns or resolves to true.
        *
        * For a single component's navigation, only one of either {@link OnActivate} or {@link OnReuse}
        * will be called, depending on the result of {@link CanReuse}.
        *
        * The `routerOnReuse` hook is called with two {@link ComponentInstruction}s as parameters, the
        * first
        * representing the current route being navigated to, and the second parameter representing the
        * previous route or `null`.
        *
        * ### Example
        * {@example router/ts/reuse/reuse_example.ts region='reuseCmp'}
        */
    export interface OnReuse {
            routerOnReuse(nextInstruction: ComponentInstruction, prevInstruction: ComponentInstruction): any;
    }
    /**
        * Defines route lifecycle method `routerOnDeactivate`, which is called by the router before
        * destroying
        * a component as part of a route change.
        *
        * The `routerOnDeactivate` hook is called with two {@link ComponentInstruction}s as parameters, the
        * first
        * representing the current route being navigated to, and the second parameter representing the
        * previous route.
        *
        * If `routerOnDeactivate` returns a promise, the route change will wait until the promise settles.
        *
        * ### Example
        * {@example router/ts/on_deactivate/on_deactivate_example.ts region='routerOnDeactivate'}
        */
    export interface OnDeactivate {
            routerOnDeactivate(nextInstruction: ComponentInstruction, prevInstruction: ComponentInstruction): any;
    }
    /**
        * Defines route lifecycle method `routerCanReuse`, which is called by the router to determine
        * whether a
        * component should be reused across routes, or whether to destroy and instantiate a new component.
        *
        * The `routerCanReuse` hook is called with two {@link ComponentInstruction}s as parameters, the
        * first
        * representing the current route being navigated to, and the second parameter representing the
        * previous route.
        *
        * If `routerCanReuse` returns or resolves to `true`, the component instance will be reused and the
        * {@link OnDeactivate} hook will be run. If `routerCanReuse` returns or resolves to `false`, a new
        * component will be instantiated, and the existing component will be deactivated and removed as
        * part of the navigation.
        *
        * If `routerCanReuse` throws or rejects, the navigation will be cancelled.
        *
        * ### Example
        * {@example router/ts/reuse/reuse_example.ts region='reuseCmp'}
        */
    export interface CanReuse {
            routerCanReuse(nextInstruction: ComponentInstruction, prevInstruction: ComponentInstruction): any;
    }
    /**
        * Defines route lifecycle method `routerCanDeactivate`, which is called by the router to determine
        * if a component can be removed as part of a navigation.
        *
        * The `routerCanDeactivate` hook is called with two {@link ComponentInstruction}s as parameters,
        * the
        * first representing the current route being navigated to, and the second parameter
        * representing the previous route.
        *
        * If `routerCanDeactivate` returns or resolves to `false`, the navigation is cancelled. If it
        * returns or
        * resolves to `true`, then the navigation continues, and the component will be deactivated
        * (the {@link OnDeactivate} hook will be run) and removed.
        *
        * If `routerCanDeactivate` throws or rejects, the navigation is also cancelled.
        *
        * ### Example
        * {@example router/ts/can_deactivate/can_deactivate_example.ts region='routerCanDeactivate'}
        */
    export interface CanDeactivate {
            routerCanDeactivate(nextInstruction: ComponentInstruction, prevInstruction: ComponentInstruction): any;
    }
}

declare module 'angular2/router/src/router/lifecycle/lifecycle_annotations' {
    import { ComponentInstruction } from 'angular2/router/src/router/instruction';
    export { routerCanReuse, routerCanDeactivate, routerOnActivate, routerOnReuse, routerOnDeactivate } from 'angular2/router/src/router/lifecycle/lifecycle_annotations_impl';
    /**
      * Defines route lifecycle hook `CanActivate`, which is called by the router to determine
      * if a component can be instantiated as part of a navigation.
      *
      * <aside class="is-right">
      * Note that unlike other lifecycle hooks, this one uses an annotation rather than an interface.
      * This is because the `CanActivate` function is called before the component is instantiated.
      * </aside>
      *
      * The `CanActivate` hook is called with two {@link ComponentInstruction}s as parameters, the first
      * representing the current route being navigated to, and the second parameter representing the
      * previous route or `null`.
      *
      * ```typescript
      * @CanActivate((next, prev) => boolean | Promise<boolean>)
      * ```
      *
      * If `CanActivate` returns or resolves to `false`, the navigation is cancelled.
      * If `CanActivate` throws or rejects, the navigation is also cancelled.
      * If `CanActivate` returns or resolves to `true`, navigation continues, the component is
      * instantiated, and the {@link OnActivate} hook of that component is called if implemented.
      *
      * ### Example
      *
      * {@example router/ts/can_activate/can_activate_example.ts region='canActivate' }
      */
    export var CanActivate: (hook: (next: ComponentInstruction, prev: ComponentInstruction) => Promise<boolean> | boolean) => ClassDecorator;
}

declare module 'angular2/router/src/router/route_config/route_config_impl' {
    import { RouteDefinition } from 'angular2/router/src/router/route_definition';
    import { RegexSerializer } from 'angular2/router/src/router/rules/route_paths/regex_route_path';
    export { RouteDefinition } from 'angular2/router/src/router/route_definition';
    /**
        * The `RouteConfig` decorator defines routes for a given component.
        *
        * It takes an array of {@link RouteDefinition}s.
        */
    export class RouteConfig {
            configs: RouteDefinition[];
            constructor(configs: RouteDefinition[]);
    }
    export abstract class AbstractRoute implements RouteDefinition {
            name: string;
            useAsDefault: boolean;
            path: string;
            regex: string;
            serializer: RegexSerializer;
            data: {
                    [key: string]: any;
            };
            constructor({name, useAsDefault, path, regex, serializer, data}: RouteDefinition);
    }
    /**
        * `Route` is a type of {@link RouteDefinition} used to route a path to a component.
        *
        * It has the following properties:
        * - `path` is a string that uses the route matcher DSL.
        * - `component` a component type.
        * - `name` is an optional `CamelCase` string representing the name of the route.
        * - `data` is an optional property of any type representing arbitrary route metadata for the given
        * route. It is injectable via {@link RouteData}.
        * - `useAsDefault` is a boolean value. If `true`, the child route will be navigated to if no child
        * route is specified during the navigation.
        *
        * ### Example
        * ```
        * import {RouteConfig, Route} from 'angular2/router';
        *
        * @RouteConfig([
        *   new Route({path: '/home', component: HomeCmp, name: 'HomeCmp' })
        * ])
        * class MyApp {}
        * ```
        */
    export class Route extends AbstractRoute {
            component: any;
            aux: string;
            constructor({name, useAsDefault, path, regex, serializer, data, component}: RouteDefinition);
    }
    /**
        * `AuxRoute` is a type of {@link RouteDefinition} used to define an auxiliary route.
        *
        * It takes an object with the following properties:
        * - `path` is a string that uses the route matcher DSL.
        * - `component` a component type.
        * - `name` is an optional `CamelCase` string representing the name of the route.
        * - `data` is an optional property of any type representing arbitrary route metadata for the given
        * route. It is injectable via {@link RouteData}.
        *
        * ### Example
        * ```
        * import {RouteConfig, AuxRoute} from 'angular2/router';
        *
        * @RouteConfig([
        *   new AuxRoute({path: '/home', component: HomeCmp})
        * ])
        * class MyApp {}
        * ```
        */
    export class AuxRoute extends AbstractRoute {
            component: any;
            constructor({name, useAsDefault, path, regex, serializer, data, component}: RouteDefinition);
    }
    /**
        * `AsyncRoute` is a type of {@link RouteDefinition} used to route a path to an asynchronously
        * loaded component.
        *
        * It has the following properties:
        * - `path` is a string that uses the route matcher DSL.
        * - `loader` is a function that returns a promise that resolves to a component.
        * - `name` is an optional `CamelCase` string representing the name of the route.
        * - `data` is an optional property of any type representing arbitrary route metadata for the given
        * route. It is injectable via {@link RouteData}.
        * - `useAsDefault` is a boolean value. If `true`, the child route will be navigated to if no child
        * route is specified during the navigation.
        *
        * ### Example
        * ```
        * import {RouteConfig, AsyncRoute} from 'angular2/router';
        *
        * @RouteConfig([
        *   new AsyncRoute({path: '/home', loader: () => Promise.resolve(MyLoadedCmp), name:
        * 'MyLoadedCmp'})
        * ])
        * class MyApp {}
        * ```
        */
    export class AsyncRoute extends AbstractRoute {
            loader: Function;
            aux: string;
            constructor({name, useAsDefault, path, regex, serializer, data, loader}: RouteDefinition);
    }
    /**
        * `Redirect` is a type of {@link RouteDefinition} used to route a path to a canonical route.
        *
        * It has the following properties:
        * - `path` is a string that uses the route matcher DSL.
        * - `redirectTo` is an array representing the link DSL.
        *
        * Note that redirects **do not** affect how links are generated. For that, see the `useAsDefault`
        * option.
        *
        * ### Example
        * ```
        * import {RouteConfig, Route, Redirect} from 'angular2/router';
        *
        * @RouteConfig([
        *   new Redirect({path: '/', redirectTo: ['/Home'] }),
        *   new Route({path: '/home', component: HomeCmp, name: 'Home'})
        * ])
        * class MyApp {}
        * ```
        */
    export class Redirect extends AbstractRoute {
            redirectTo: any[];
            constructor({name, useAsDefault, path, regex, serializer, data, redirectTo}: RouteDefinition);
    }
}

declare module 'angular2/router/src/router/rules/route_paths/regex_route_path' {
    import { Url } from 'angular2/router/src/router/url_parser';
    import { RoutePath, GeneratedUrl, MatchedUrl } from 'angular2/router/src/router/rules/route_paths/route_path';
    export interface RegexSerializer {
        (params: {
            [key: string]: any;
        }): GeneratedUrl;
    }
    export class RegexRoutePath implements RoutePath {
        hash: string;
        terminal: boolean;
        specificity: string;
        constructor(_reString: string, _serializer: RegexSerializer);
        matchUrl(url: Url): MatchedUrl;
        generateUrl(params: {
            [key: string]: any;
        }): GeneratedUrl;
        toString(): string;
    }
}

declare module 'angular2/router/src/router/lifecycle/lifecycle_annotations_impl' {
    export class RouteLifecycleHook {
        name: string;
        constructor(name: string);
    }
    export class CanActivate {
        fn: Function;
        constructor(fn: Function);
    }
    export const routerCanReuse: RouteLifecycleHook;
    export const routerCanDeactivate: RouteLifecycleHook;
    export const routerOnActivate: RouteLifecycleHook;
    export const routerOnReuse: RouteLifecycleHook;
    export const routerOnDeactivate: RouteLifecycleHook;
}

declare module 'angular2/router/src/router/url_parser' {
    export function convertUrlParamsToArray(urlParams: {
        [key: string]: any;
    }): string[];
    export function serializeParams(urlParams: {
        [key: string]: any;
    }, joiner?: string): string;
    /**
      * This class represents a parsed URL
      */
    export class Url {
        path: string;
        child: Url;
        auxiliary: Url[];
        params: {
            [key: string]: any;
        };
        constructor(path: string, child?: Url, auxiliary?: Url[], params?: {
            [key: string]: any;
        });
        toString(): string;
        segmentToString(): string;
    }
    export class RootUrl extends Url {
        constructor(path: string, child?: Url, auxiliary?: Url[], params?: {
            [key: string]: any;
        });
        toString(): string;
        segmentToString(): string;
    }
    export function pathSegmentsToUrl(pathSegments: string[]): Url;
    export class UrlParser {
        peekStartsWith(str: string): boolean;
        capture(str: string): void;
        parse(url: string): Url;
        parseRoot(): RootUrl;
        parseSegment(): Url;
        parseQueryParams(): {
            [key: string]: any;
        };
        parseMatrixParams(): {
            [key: string]: any;
        };
        parseParam(params: {
            [key: string]: any;
        }): void;
        parseAuxiliaryRoutes(): Url[];
    }
    export var parser: UrlParser;
}

declare module 'angular2/router/src/router/rules/route_paths/route_path' {
    import { Url } from 'angular2/router/src/router/url_parser';
    export class MatchedUrl {
        urlPath: string;
        urlParams: string[];
        allParams: {
            [key: string]: any;
        };
        auxiliary: Url[];
        rest: Url;
        constructor(urlPath: string, urlParams: string[], allParams: {
            [key: string]: any;
        }, auxiliary: Url[], rest: Url);
    }
    export class GeneratedUrl {
        urlPath: string;
        urlParams: {
            [key: string]: any;
        };
        constructor(urlPath: string, urlParams: {
            [key: string]: any;
        });
    }
    export interface RoutePath {
        specificity: string;
        terminal: boolean;
        hash: string;
        matchUrl(url: Url): MatchedUrl;
        generateUrl(params: {
            [key: string]: any;
        }): GeneratedUrl;
        toString(): string;
    }
}

