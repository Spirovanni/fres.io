// Generated by dts-bundle v0.4.3
// Dependencies for this module:
//   ../../angular2/src/facade/lang
//   ../../angular2/src/facade/async
//   ../../angular2/core
//   ../../angular2/src/common/forms/directives/control_value_accessor
//   ../../angular2/src/common/forms/directives/ng_control

declare module 'angular2/common' {
    export * from 'angular2/common/src/common/pipes';
    export * from 'angular2/common/src/common/directives';
    export * from 'angular2/common/src/common/forms';
    export * from 'angular2/common/src/common/common_directives';
}

declare module 'angular2/common/src/common/pipes' {
    /**
      * @module
      * @description
      * This module provides a set of common Pipes.
      */
    export { AsyncPipe } from 'angular2/common/src/common/pipes/async_pipe';
    export { DatePipe } from 'angular2/common/src/common/pipes/date_pipe';
    export { JsonPipe } from 'angular2/common/src/common/pipes/json_pipe';
    export { SlicePipe } from 'angular2/common/src/common/pipes/slice_pipe';
    export { LowerCasePipe } from 'angular2/common/src/common/pipes/lowercase_pipe';
    export { NumberPipe, DecimalPipe, PercentPipe, CurrencyPipe } from 'angular2/common/src/common/pipes/number_pipe';
    export { UpperCasePipe } from 'angular2/common/src/common/pipes/uppercase_pipe';
    export { ReplacePipe } from 'angular2/common/src/common/pipes/replace_pipe';
    export { I18nPluralPipe } from 'angular2/common/src/common/pipes/i18n_plural_pipe';
    export { I18nSelectPipe } from 'angular2/common/src/common/pipes/i18n_select_pipe';
    export { COMMON_PIPES } from 'angular2/common/src/common/pipes/common_pipes';
}

declare module 'angular2/common/src/common/directives' {
    /**
      * @module
      * @description
      * Common directives shipped with Angular.
      */
    export { NgClass } from 'angular2/common/src/common/directives/ng_class';
    export { NgFor } from 'angular2/common/src/common/directives/ng_for';
    export { NgIf } from 'angular2/common/src/common/directives/ng_if';
    export { NgStyle } from 'angular2/common/src/common/directives/ng_style';
    export { NgSwitch, NgSwitchWhen, NgSwitchDefault } from 'angular2/common/src/common/directives/ng_switch';
    export * from 'angular2/common/src/common/directives/observable_list_diff';
    export { CORE_DIRECTIVES } from 'angular2/common/src/common/directives/core_directives';
}

declare module 'angular2/common/src/common/forms' {
    /**
        * @module
        * @description
        * This module is used for handling user input, by defining and building a {@link ControlGroup} that
        * consists of
        * {@link Control} objects, and mapping them onto the DOM. {@link Control} objects can then be used
        * to read information
        * from the form DOM elements.
        *
        * This module is not included in the `angular2` module; you must import the forms module
        * explicitly.
        *
        */
    export { AbstractControl, Control, ControlGroup, ControlArray } from 'angular2/common/src/common/forms/model';
    export { AbstractControlDirective } from 'angular2/common/src/common/forms/directives/abstract_control_directive';
    export { Form } from 'angular2/common/src/common/forms/directives/form_interface';
    export { ControlContainer } from 'angular2/common/src/common/forms/directives/control_container';
    export { NgControlName } from 'angular2/common/src/common/forms/directives/ng_control_name';
    export { NgFormControl } from 'angular2/common/src/common/forms/directives/ng_form_control';
    export { NgModel } from 'angular2/common/src/common/forms/directives/ng_model';
    export { NgControl } from 'angular2/common/src/common/forms/directives/ng_control';
    export { NgControlGroup } from 'angular2/common/src/common/forms/directives/ng_control_group';
    export { NgFormModel } from 'angular2/common/src/common/forms/directives/ng_form_model';
    export { NgForm } from 'angular2/common/src/common/forms/directives/ng_form';
    export { ControlValueAccessor, NG_VALUE_ACCESSOR } from 'angular2/common/src/common/forms/directives/control_value_accessor';
    export { DefaultValueAccessor } from 'angular2/common/src/common/forms/directives/default_value_accessor';
    export { NgControlStatus } from 'angular2/common/src/common/forms/directives/ng_control_status';
    export { CheckboxControlValueAccessor } from 'angular2/common/src/common/forms/directives/checkbox_value_accessor';
    export { NgSelectOption, SelectControlValueAccessor } from 'angular2/common/src/common/forms/directives/select_control_value_accessor';
    export { FORM_DIRECTIVES, RadioButtonState } from 'angular2/common/src/common/forms/directives';
    export { NG_VALIDATORS, NG_ASYNC_VALIDATORS, Validators } from 'angular2/common/src/common/forms/validators';
    export { RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, Validator } from 'angular2/common/src/common/forms/directives/validators';
    export { FormBuilder } from 'angular2/common/src/common/forms/form_builder';
    import { Type } from 'angular2/src/facade/lang';
    /**
        * Shorthand set of providers used for building Angular forms.
        *
        * ### Example
        *
        * ```typescript
        * bootstrap(MyApp, [FORM_PROVIDERS]);
        * ```
        */
    export const FORM_PROVIDERS: Type[];
    /**
        * See {@link FORM_PROVIDERS} instead.
        *
        * @deprecated
        */
    export const FORM_BINDINGS: Type[];
}

declare module 'angular2/common/src/common/common_directives' {
    import { Type } from 'angular2/src/facade/lang';
    /**
      * A collection of Angular core directives that are likely to be used in each and every Angular
      * application. This includes core directives (e.g., NgIf and NgFor), and forms directives (e.g.,
      * NgModel).
      *
      * This collection can be used to quickly enumerate all the built-in directives in the `directives`
      * property of the `@Component` or `@View` decorators.
      *
      * ### Example
      *
      * Instead of writing:
      *
      * ```typescript
      * import {NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, NgModel, NgForm} from
      * 'angular2/common';
      * import {OtherDirective} from './myDirectives';
      *
      * @Component({
      *   selector: 'my-component',
      *   templateUrl: 'myComponent.html',
      *   directives: [NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, NgModel, NgForm,
      * OtherDirective]
      * })
      * export class MyComponent {
      *   ...
      * }
      * ```
      * one could import all the common directives at once:
      *
      * ```typescript
      * import {COMMON_DIRECTIVES} from 'angular2/common';
      * import {OtherDirective} from './myDirectives';
      *
      * @Component({
      *   selector: 'my-component',
      *   templateUrl: 'myComponent.html',
      *   directives: [COMMON_DIRECTIVES, OtherDirective]
      * })
      * export class MyComponent {
      *   ...
      * }
      * ```
      */
    export const COMMON_DIRECTIVES: Type[][];
}

declare module 'angular2/common/src/common/pipes/async_pipe' {
    import { Observable, EventEmitter } from 'angular2/src/facade/async';
    import { ChangeDetectorRef, OnDestroy, PipeTransform } from 'angular2/core';
    /**
      * The `async` pipe subscribes to an Observable or Promise and returns the latest value it has
      * emitted.
      * When a new value is emitted, the `async` pipe marks the component to be checked for changes.
      *
      * ### Example
      *
      * This example binds a `Promise` to the view. Clicking the `Resolve` button resolves the
      * promise.
      *
      * {@example core/pipes/ts/async_pipe/async_pipe_example.ts region='AsyncPipe'}
      *
      * It's also possible to use `async` with Observables. The example below binds the `time` Observable
      * to the view. Every 500ms, the `time` Observable updates the view with the current time.
      *
      * ```typescript
      * ```
      */
    export class AsyncPipe implements PipeTransform, OnDestroy {
        constructor(_ref: ChangeDetectorRef);
        ngOnDestroy(): void;
        transform(obj: Observable<any> | Promise<any> | EventEmitter<any>, args?: any[]): any;
    }
}

declare module 'angular2/common/src/common/pipes/date_pipe' {
    import { PipeTransform } from 'angular2/core';
    /**
      * Formats a date value to a string based on the requested format.
      *
      * WARNINGS:
      * - this pipe is marked as pure hence it will not be re-evaluated when the input is mutated.
      *   Instead users should treat the date as an immutable object and change the reference when the
      *   pipe needs to re-run (this is to avoid reformatting the date on every change detection run
      *   which would be an expensive operation).
      * - this pipe uses the Internationalization API. Therefore it is only reliable in Chrome and Opera
      *   browsers.
      *
      * ## Usage
      *
      *     expression | date[:format]
      *
      * where `expression` is a date object or a number (milliseconds since UTC epoch) and
      * `format` indicates which date/time components to include:
      *
      *  | Component | Symbol | Short Form   | Long Form         | Numeric   | 2-digit   |
      *  |-----------|:------:|--------------|-------------------|-----------|-----------|
      *  | era       |   G    | G (AD)       | GGGG (Anno Domini)| -         | -         |
      *  | year      |   y    | -            | -                 | y (2015)  | yy (15)   |
      *  | month     |   M    | MMM (Sep)    | MMMM (September)  | M (9)     | MM (09)   |
      *  | day       |   d    | -            | -                 | d (3)     | dd (03)   |
      *  | weekday   |   E    | EEE (Sun)    | EEEE (Sunday)     | -         | -         |
      *  | hour      |   j    | -            | -                 | j (13)    | jj (13)   |
      *  | hour12    |   h    | -            | -                 | h (1 PM)  | hh (01 PM)|
      *  | hour24    |   H    | -            | -                 | H (13)    | HH (13)   |
      *  | minute    |   m    | -            | -                 | m (5)     | mm (05)   |
      *  | second    |   s    | -            | -                 | s (9)     | ss (09)   |
      *  | timezone  |   z    | -            | z (Pacific Standard Time)| -  | -         |
      *  | timezone  |   Z    | Z (GMT-8:00) | -                 | -         | -         |
      *
      * In javascript, only the components specified will be respected (not the ordering,
      * punctuations, ...) and details of the formatting will be dependent on the locale.
      * On the other hand in Dart version, you can also include quoted text as well as some extra
      * date/time components such as quarter. For more information see:
      * https://api.dartlang.org/apidocs/channels/stable/dartdoc-viewer/intl/intl.DateFormat.
      *
      * `format` can also be one of the following predefined formats:
      *
      *  - `'medium'`: equivalent to `'yMMMdjms'` (e.g. Sep 3, 2010, 12:05:08 PM for en-US)
      *  - `'short'`: equivalent to `'yMdjm'` (e.g. 9/3/2010, 12:05 PM for en-US)
      *  - `'fullDate'`: equivalent to `'yMMMMEEEEd'` (e.g. Friday, September 3, 2010 for en-US)
      *  - `'longDate'`: equivalent to `'yMMMMd'` (e.g. September 3, 2010)
      *  - `'mediumDate'`: equivalent to `'yMMMd'` (e.g. Sep 3, 2010 for en-US)
      *  - `'shortDate'`: equivalent to `'yMd'` (e.g. 9/3/2010 for en-US)
      *  - `'mediumTime'`: equivalent to `'jms'` (e.g. 12:05:08 PM for en-US)
      *  - `'shortTime'`: equivalent to `'jm'` (e.g. 12:05 PM for en-US)
      *
      * Timezone of the formatted text will be the local system timezone of the end-users machine.
      *
      * ### Examples
      *
      * Assuming `dateObj` is (year: 2015, month: 6, day: 15, hour: 21, minute: 43, second: 11)
      * in the _local_ time and locale is 'en-US':
      *
      * ```
      *     {{ dateObj | date }}               // output is 'Jun 15, 2015'
      *     {{ dateObj | date:'medium' }}      // output is 'Jun 15, 2015, 9:43:11 PM'
      *     {{ dateObj | date:'shortTime' }}   // output is '9:43 PM'
      *     {{ dateObj | date:'mmss' }}        // output is '43:11'
      * ```
      *
      * {@example core/pipes/ts/date_pipe/date_pipe_example.ts region='DatePipe'}
      */
    export class DatePipe implements PipeTransform {
        transform(value: any, args: any[]): string;
        supports(obj: any): boolean;
    }
}

declare module 'angular2/common/src/common/pipes/json_pipe' {
    import { PipeTransform } from 'angular2/core';
    /**
      * Transforms any input value using `JSON.stringify`. Useful for debugging.
      *
      * ### Example
      * {@example core/pipes/ts/json_pipe/json_pipe_example.ts region='JsonPipe'}
      */
    export class JsonPipe implements PipeTransform {
        transform(value: any, args?: any[]): string;
    }
}

declare module 'angular2/common/src/common/pipes/slice_pipe' {
    import { PipeTransform } from 'angular2/core';
    /**
      * Creates a new List or String containing only a subset (slice) of the
      * elements.
      *
      * The starting index of the subset to return is specified by the `start` parameter.
      *
      * The ending index of the subset to return is specified by the optional `end` parameter.
      *
      * ### Usage
      *
      *     expression | slice:start[:end]
      *
      * All behavior is based on the expected behavior of the JavaScript API
      * Array.prototype.slice() and String.prototype.slice()
      *
      * Where the input expression is a [List] or [String], and `start` is:
      *
      * - **a positive integer**: return the item at _start_ index and all items after
      * in the list or string expression.
      * - **a negative integer**: return the item at _start_ index from the end and all items after
      * in the list or string expression.
      * - **`|start|` greater than the size of the expression**: return an empty list or string.
      * - **`|start|` negative greater than the size of the expression**: return entire list or
      * string expression.
      *
      * and where `end` is:
      *
      * - **omitted**: return all items until the end of the input
      * - **a positive integer**: return all items before _end_ index of the list or string
      * expression.
      * - **a negative integer**: return all items before _end_ index from the end of the list
      * or string expression.
      *
      * When operating on a [List], the returned list is always a copy even when all
      * the elements are being returned.
      *
      * ## List Example
      *
      * This `ngFor` example:
      *
      * {@example core/pipes/ts/slice_pipe/slice_pipe_example.ts region='SlicePipe_list'}
      *
      * produces the following:
      *
      *     <li>b</li>
      *     <li>c</li>
      *
      * ## String Examples
      *
      * {@example core/pipes/ts/slice_pipe/slice_pipe_example.ts region='SlicePipe_string'}
      */
    export class SlicePipe implements PipeTransform {
        transform(value: any, args?: any[]): any;
    }
}

declare module 'angular2/common/src/common/pipes/lowercase_pipe' {
    import { PipeTransform } from 'angular2/core';
    /**
      * Transforms text to lowercase.
      *
      * ### Example
      *
      * {@example core/pipes/ts/lowerupper_pipe/lowerupper_pipe_example.ts region='LowerUpperPipe'}
      */
    export class LowerCasePipe implements PipeTransform {
        transform(value: string, args?: any[]): string;
    }
}

declare module 'angular2/common/src/common/pipes/number_pipe' {
    import { PipeTransform } from 'angular2/core';
    /**
        * Internal base class for numeric pipes.
        */
    export class NumberPipe {
    }
    /**
        * WARNING: this pipe uses the Internationalization API.
        * Therefore it is only reliable in Chrome and Opera browsers.
        *
        * Formats a number as local text. i.e. group sizing and separator and other locale-specific
        * configurations are based on the active locale.
        *
        * ### Usage
        *
        *     expression | number[:digitInfo]
        *
        * where `expression` is a number and `digitInfo` has the following format:
        *
        *     {minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}
        *
        * - minIntegerDigits is the minimum number of integer digits to use. Defaults to 1.
        * - minFractionDigits is the minimum number of digits after fraction. Defaults to 0.
        * - maxFractionDigits is the maximum number of digits after fraction. Defaults to 3.
        *
        * For more information on the acceptable range for each of these numbers and other
        * details see your native internationalization library.
        *
        * ### Example
        *
        * {@example core/pipes/ts/number_pipe/number_pipe_example.ts region='NumberPipe'}
        */
    export class DecimalPipe extends NumberPipe implements PipeTransform {
            transform(value: any, args: any[]): string;
    }
    /**
        * WARNING: this pipe uses the Internationalization API.
        * Therefore it is only reliable in Chrome and Opera browsers.
        *
        * Formats a number as local percent.
        *
        * ### Usage
        *
        *     expression | percent[:digitInfo]
        *
        * For more information about `digitInfo` see {@link DecimalPipe}
        *
        * ### Example
        *
        * {@example core/pipes/ts/number_pipe/number_pipe_example.ts region='PercentPipe'}
        */
    export class PercentPipe extends NumberPipe implements PipeTransform {
            transform(value: any, args: any[]): string;
    }
    /**
        * WARNING: this pipe uses the Internationalization API.
        * Therefore it is only reliable in Chrome and Opera browsers.
        *
        * Formats a number as local currency.
        *
        * ### Usage
        *
        *     expression | currency[:currencyCode[:symbolDisplay[:digitInfo]]]
        *
        * where `currencyCode` is the ISO 4217 currency code, such as "USD" for the US dollar and
        * "EUR" for the euro. `symbolDisplay` is a boolean indicating whether to use the currency
        * symbol (e.g. $) or the currency code (e.g. USD) in the output. The default for this value
        * is `false`.
        * For more information about `digitInfo` see {@link DecimalPipe}
        *
        * ### Example
        *
        * {@example core/pipes/ts/number_pipe/number_pipe_example.ts region='CurrencyPipe'}
        */
    export class CurrencyPipe extends NumberPipe implements PipeTransform {
            transform(value: any, args: any[]): string;
    }
}

declare module 'angular2/common/src/common/pipes/uppercase_pipe' {
    import { PipeTransform } from 'angular2/core';
    /**
      * Implements uppercase transforms to text.
      *
      * ### Example
      *
      * {@example core/pipes/ts/lowerupper_pipe/lowerupper_pipe_example.ts region='LowerUpperPipe'}
      */
    export class UpperCasePipe implements PipeTransform {
        transform(value: string, args?: any[]): string;
    }
}

declare module 'angular2/common/src/common/pipes/replace_pipe' {
    import { PipeTransform } from 'angular2/core';
    /**
      * Creates a new String with some or all of the matches of a pattern replaced by
      * a replacement.
      *
      * The pattern to be matched is specified by the 'pattern' parameter.
      *
      * The replacement to be set is specified by the 'replacement' parameter.
      *
      * An optional 'flags' parameter can be set.
      *
      * ### Usage
      *
      *     expression | replace:pattern:replacement
      *
      * All behavior is based on the expected behavior of the JavaScript API
      * String.prototype.replace() function.
      *
      * Where the input expression is a [String] or [Number] (to be treated as a string),
      * the `pattern` is a [String] or [RegExp],
      * the 'replacement' is a [String] or [Function].
      *
      * --Note--: The 'pattern' parameter will be converted to a RegExp instance. Make sure to escape the
      * string properly if you are matching for regular expression special characters like parenthesis,
      * brackets etc.
      */
    export class ReplacePipe implements PipeTransform {
        transform(value: any, args: any[]): any;
    }
}

declare module 'angular2/common/src/common/pipes/i18n_plural_pipe' {
    import { PipeTransform } from 'angular2/core';
    /**
      *
      *  Maps a value to a string that pluralizes the value properly.
      *
      *  ## Usage
      *
      *  expression | i18nPlural:mapping
      *
      *  where `expression` is a number and `mapping` is an object that indicates the proper text for
      *  when the `expression` evaluates to 0, 1, or some other number.  You can interpolate the actual
      *  value into the text using the `#` sign.
      *
      *  ## Example
      *
      *  ```
      *  <div>
      *    {{ messages.length | i18nPlural: messageMapping }}
      *  </div>
      *
      *  class MyApp {
      *    messages: any[];
      *    messageMapping: any = {
      *      '=0': 'No messages.',
      *      '=1': 'One message.',
      *      'other': '# messages.'
      *    }
      *    ...
      *  }
      *  ```
      *
      */
    export class I18nPluralPipe implements PipeTransform {
        transform(value: number, args?: any[]): string;
    }
}

declare module 'angular2/common/src/common/pipes/i18n_select_pipe' {
    import { PipeTransform } from 'angular2/core';
    /**
      *
      *  Generic selector that displays the string that matches the current value.
      *
      *  ## Usage
      *
      *  expression | i18nSelect:mapping
      *
      *  where `mapping` is an object that indicates the text that should be displayed
      *  for different values of the provided `expression`.
      *
      *  ## Example
      *
      *  ```
      *  <div>
      *    {{ gender | i18nSelect: inviteMap }}
      *  </div>
      *
      *  class MyApp {
      *    gender: string = 'male';
      *    inviteMap: any = {
      *      'male': 'Invite her.',
      *      'female': 'Invite him.',
      *      'other': 'Invite them.'
      *    }
      *    ...
      *  }
      *  ```
      */
    export class I18nSelectPipe implements PipeTransform {
        transform(value: string, args?: any[]): string;
    }
}

declare module 'angular2/common/src/common/pipes/common_pipes' {
    /**
        * @module
        * @description
        * This module provides a set of common Pipes.
        */
    import { AsyncPipe } from 'angular2/common/src/common/pipes/async_pipe';
    import { UpperCasePipe } from 'angular2/common/src/common/pipes/uppercase_pipe';
    import { SlicePipe } from 'angular2/common/src/common/pipes/slice_pipe';
    import { ReplacePipe } from 'angular2/common/src/common/pipes/replace_pipe';
    /**
        * A collection of Angular core pipes that are likely to be used in each and every
        * application.
        *
        * This collection can be used to quickly enumerate all the built-in pipes in the `pipes`
        * property of the `@Component` or `@View` decorators.
        */
    export const COMMON_PIPES: (typeof AsyncPipe | typeof UpperCasePipe | typeof SlicePipe | typeof ReplacePipe)[];
}

declare module 'angular2/common/src/common/directives/ng_class' {
    import { DoCheck, OnDestroy, ElementRef, IterableDiffers, KeyValueDiffers, Renderer } from 'angular2/core';
    /**
      * The `NgClass` directive conditionally adds and removes CSS classes on an HTML element based on
      * an expression's evaluation result.
      *
      * The result of an expression evaluation is interpreted differently depending on type of
      * the expression evaluation result:
      * - `string` - all the CSS classes listed in a string (space delimited) are added
      * - `Array` - all the CSS classes (Array elements) are added
      * - `Object` - each key corresponds to a CSS class name while values are interpreted as expressions
      * evaluating to `Boolean`. If a given expression evaluates to `true` a corresponding CSS class
      * is added - otherwise it is removed.
      *
      * While the `NgClass` directive can interpret expressions evaluating to `string`, `Array`
      * or `Object`, the `Object`-based version is the most often used and has an advantage of keeping
      * all the CSS class names in a template.
      *
      * ### Example ([live demo](http://plnkr.co/edit/a4YdtmWywhJ33uqfpPPn?p=preview)):
      *
      * ```
      * import {Component} from 'angular2/core';
      * import {NgClass} from 'angular2/common';
      *
      * @Component({
      *   selector: 'toggle-button',
      *   inputs: ['isDisabled'],
      *   template: `
      *      <div class="button" [ngClass]="{active: isOn, disabled: isDisabled}"
      *          (click)="toggle(!isOn)">
      *          Click me!
      *      </div>`,
      *   styles: [`
      *     .button {
      *       width: 120px;
      *       border: medium solid black;
      *     }
      *
      *     .active {
      *       background-color: red;
      *    }
      *
      *     .disabled {
      *       color: gray;
      *       border: medium solid gray;
      *     }
      *   `]
      *   directives: [NgClass]
      * })
      * class ToggleButton {
      *   isOn = false;
      *   isDisabled = false;
      *
      *   toggle(newState) {
      *     if (!this.isDisabled) {
      *       this.isOn = newState;
      *     }
      *   }
      * }
      * ```
      */
    export class NgClass implements DoCheck, OnDestroy {
        constructor(_iterableDiffers: IterableDiffers, _keyValueDiffers: KeyValueDiffers, _ngEl: ElementRef, _renderer: Renderer);
        initialClasses: string;
        rawClass: string | string[] | Set<string> | {
            [key: string]: any;
        };
        ngDoCheck(): void;
        ngOnDestroy(): void;
    }
}

declare module 'angular2/common/src/common/directives/ng_for' {
    import { DoCheck, ChangeDetectorRef, IterableDiffers, ViewContainerRef, TemplateRef, TrackByFn } from 'angular2/core';
    /**
      * The `NgFor` directive instantiates a template once per item from an iterable. The context for
      * each instantiated template inherits from the outer context with the given loop variable set
      * to the current item from the iterable.
      *
      * # Local Variables
      *
      * `NgFor` provides several exported values that can be aliased to local variables:
      *
      * * `index` will be set to the current loop iteration for each template context.
      * * `last` will be set to a boolean value indicating whether the item is the last one in the
      *   iteration.
      * * `even` will be set to a boolean value indicating whether this item has an even index.
      * * `odd` will be set to a boolean value indicating whether this item has an odd index.
      *
      * # Change Propagation
      *
      * When the contents of the iterator changes, `NgFor` makes the corresponding changes to the DOM:
      *
      * * When an item is added, a new instance of the template is added to the DOM.
      * * When an item is removed, its template instance is removed from the DOM.
      * * When items are reordered, their respective templates are reordered in the DOM.
      * * Otherwise, the DOM element for that item will remain the same.
      *
      * Angular uses object identity to track insertions and deletions within the iterator and reproduce
      * those changes in the DOM. This has important implications for animations and any stateful
      * controls
      * (such as `<input>` elements which accept user input) that are present. Inserted rows can be
      * animated in, deleted rows can be animated out, and unchanged rows retain any unsaved state such
      * as user input.
      *
      * It is possible for the identities of elements in the iterator to change while the data does not.
      * This can happen, for example, if the iterator produced from an RPC to the server, and that
      * RPC is re-run. Even if the data hasn't changed, the second response will produce objects with
      * different identities, and Angular will tear down the entire DOM and rebuild it (as if all old
      * elements were deleted and all new elements inserted). This is an expensive operation and should
      * be avoided if possible.
      *
      * # Syntax
      *
      * - `<li *ngFor="#item of items; #i = index">...</li>`
      * - `<li template="ngFor #item of items; #i = index">...</li>`
      * - `<template ngFor #item [ngForOf]="items" #i="index"><li>...</li></template>`
      *
      * ### Example
      *
      * See a [live demo](http://plnkr.co/edit/KVuXxDp0qinGDyo307QW?p=preview) for a more detailed
      * example.
      */
    export class NgFor implements DoCheck {
        _ngForTrackBy: TrackByFn;
        constructor(_viewContainer: ViewContainerRef, _templateRef: TemplateRef, _iterableDiffers: IterableDiffers, _cdr: ChangeDetectorRef);
        ngForOf: any;
        ngForTemplate: TemplateRef;
        ngForTrackBy: TrackByFn;
        ngDoCheck(): void;
    }
}

declare module 'angular2/common/src/common/directives/ng_if' {
    import { ViewContainerRef, TemplateRef } from 'angular2/core';
    /**
      * Removes or recreates a portion of the DOM tree based on an {expression}.
      *
      * If the expression assigned to `ngIf` evaluates to a false value then the element
      * is removed from the DOM, otherwise a clone of the element is reinserted into the DOM.
      *
      * ### Example ([live demo](http://plnkr.co/edit/fe0kgemFBtmQOY31b4tw?p=preview)):
      *
      * ```
      * <div *ngIf="errorCount > 0" class="error">
      *   <!-- Error message displayed when the errorCount property on the current context is greater
      * than 0. -->
      *   {{errorCount}} errors detected
      * </div>
      * ```
      *
      * ### Syntax
      *
      * - `<div *ngIf="condition">...</div>`
      * - `<div template="ngIf condition">...</div>`
      * - `<template [ngIf]="condition"><div>...</div></template>`
      */
    export class NgIf {
        constructor(_viewContainer: ViewContainerRef, _templateRef: TemplateRef);
        ngIf: any;
    }
}

declare module 'angular2/common/src/common/directives/ng_style' {
    import { DoCheck, KeyValueDiffers, ElementRef, Renderer } from 'angular2/core';
    /**
      * The `NgStyle` directive changes styles based on a result of expression evaluation.
      *
      * An expression assigned to the `ngStyle` property must evaluate to an object and the
      * corresponding element styles are updated based on changes to this object. Style names to update
      * are taken from the object's keys, and values - from the corresponding object's values.
      *
      * ### Syntax
      *
      * - `<div [ngStyle]="{'font-style': style}"></div>`
      * - `<div [ngStyle]="styleExp"></div>` - here the `styleExp` must evaluate to an object
      *
      * ### Example ([live demo](http://plnkr.co/edit/YamGS6GkUh9GqWNQhCyM?p=preview)):
      *
      * ```
      * import {Component} from 'angular2/core';
      * import {NgStyle} from 'angular2/common';
      *
      * @Component({
      *  selector: 'ngStyle-example',
      *  template: `
      *    <h1 [ngStyle]="{'font-style': style, 'font-size': size, 'font-weight': weight}">
      *      Change style of this text!
      *    </h1>
      *
      *    <hr>
      *
      *    <label>Italic: <input type="checkbox" (change)="changeStyle($event)"></label>
      *    <label>Bold: <input type="checkbox" (change)="changeWeight($event)"></label>
      *    <label>Size: <input type="text" [value]="size" (change)="size = $event.target.value"></label>
      *  `,
      *  directives: [NgStyle]
      * })
      * export class NgStyleExample {
      *    style = 'normal';
      *    weight = 'normal';
      *    size = '20px';
      *
      *    changeStyle($event: any) {
      *      this.style = $event.target.checked ? 'italic' : 'normal';
      *    }
      *
      *    changeWeight($event: any) {
      *      this.weight = $event.target.checked ? 'bold' : 'normal';
      *    }
      * }
      * ```
      *
      * In this example the `font-style`, `font-size` and `font-weight` styles will be updated
      * based on the `style` property's value changes.
      */
    export class NgStyle implements DoCheck {
        constructor(_differs: KeyValueDiffers, _ngEl: ElementRef, _renderer: Renderer);
        rawStyle: {
            [key: string]: string;
        };
        ngDoCheck(): void;
    }
}

declare module 'angular2/common/src/common/directives/ng_switch' {
    import { ViewContainerRef, TemplateRef } from 'angular2/core';
    /**
        * Adds or removes DOM sub-trees when their match expressions match the switch expression.
        *
        * Elements within `NgSwitch` but without `NgSwitchWhen` or `NgSwitchDefault` directives will be
        * preserved at the location as specified in the template.
        *
        * `NgSwitch` simply inserts nested elements based on which match expression matches the value
        * obtained from the evaluated switch expression. In other words, you define a container element
        * (where you place the directive with a switch expression on the
        * **`[ngSwitch]="..."` attribute**), define any inner elements inside of the directive and
        * place a `[ngSwitchWhen]` attribute per element.
        *
        * The `ngSwitchWhen` property is used to inform `NgSwitch` which element to display when the
        * expression is evaluated. If a matching expression is not found via a `ngSwitchWhen` property
        * then an element with the `ngSwitchDefault` attribute is displayed.
        *
        * ### Example ([live demo](http://plnkr.co/edit/DQMTII95CbuqWrl3lYAs?p=preview))
        *
        * ```typescript
        * @Component({selector: 'app'})
        * @View({
        *   template: `
        *     <p>Value = {{value}}</p>
        *     <button (click)="inc()">Increment</button>
        *
        *     <div [ngSwitch]="value">
        *       <p *ngSwitchWhen="'init'">increment to start</p>
        *       <p *ngSwitchWhen="0">0, increment again</p>
        *       <p *ngSwitchWhen="1">1, increment again</p>
        *       <p *ngSwitchWhen="2">2, stop incrementing</p>
        *       <p *ngSwitchDefault>&gt; 2, STOP!</p>
        *     </div>
        *
        *     <!-- alternate syntax -->
        *
        *     <p [ngSwitch]="value">
        *       <template ngSwitchWhen="init">increment to start</template>
        *       <template [ngSwitchWhen]="0">0, increment again</template>
        *       <template [ngSwitchWhen]="1">1, increment again</template>
        *       <template [ngSwitchWhen]="2">2, stop incrementing</template>
        *       <template ngSwitchDefault>&gt; 2, STOP!</template>
        *     </p>
        *   `,
        *   directives: [NgSwitch, NgSwitchWhen, NgSwitchDefault]
        * })
        * export class App {
        *   value = 'init';
        *
        *   inc() {
        *     this.value = this.value === 'init' ? 0 : this.value + 1;
        *   }
        * }
        *
        * bootstrap(App).catch(err => console.error(err));
        * ```
        */
    export class NgSwitch {
            ngSwitch: any;
    }
    /**
        * Insert the sub-tree when the `ngSwitchWhen` expression evaluates to the same value as the
        * enclosing switch expression.
        *
        * If multiple match expression match the switch expression value, all of them are displayed.
        *
        * See {@link NgSwitch} for more details and example.
        */
    export class NgSwitchWhen {
            constructor(viewContainer: ViewContainerRef, templateRef: TemplateRef, ngSwitch: NgSwitch);
            ngSwitchWhen: any;
    }
    /**
        * Default case statements are displayed when no match expression matches the switch expression
        * value.
        *
        * See {@link NgSwitch} for more details and example.
        */
    export class NgSwitchDefault {
            constructor(viewContainer: ViewContainerRef, templateRef: TemplateRef, sswitch: NgSwitch);
    }
}

declare module 'angular2/common/src/common/directives/observable_list_diff' {
    /**
      * This module exists in Dart, but not in Typescript. This exported symbol
      * is only here to help Typescript think this is a module.
      */
    export var workaround_empty_observable_list_diff: any;
}

declare module 'angular2/common/src/common/directives/core_directives' {
    import { Type } from 'angular2/src/facade/lang';
    /**
      * A collection of Angular core directives that are likely to be used in each and every Angular
      * application.
      *
      * This collection can be used to quickly enumerate all the built-in directives in the `directives`
      * property of the `@View` annotation.
      *
      * ### Example ([live demo](http://plnkr.co/edit/yakGwpCdUkg0qfzX5m8g?p=preview))
      *
      * Instead of writing:
      *
      * ```typescript
      * import {NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault} from 'angular2/common';
      * import {OtherDirective} from './myDirectives';
      *
      * @Component({
      *   selector: 'my-component',
      *   templateUrl: 'myComponent.html',
      *   directives: [NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, OtherDirective]
      * })
      * export class MyComponent {
      *   ...
      * }
      * ```
      * one could import all the core directives at once:
      *
      * ```typescript
      * import {CORE_DIRECTIVES} from 'angular2/common';
      * import {OtherDirective} from './myDirectives';
      *
      * @Component({
      *   selector: 'my-component',
      *   templateUrl: 'myComponent.html',
      *   directives: [CORE_DIRECTIVES, OtherDirective]
      * })
      * export class MyComponent {
      *   ...
      * }
      * ```
      */
    export const CORE_DIRECTIVES: Type[];
}

declare module 'angular2/common/src/common/forms/model' {
    import { Observable } from 'angular2/src/facade/async';
    /**
        * Indicates that a Control is valid, i.e. that no errors exist in the input value.
        */
    export const VALID: string;
    /**
        * Indicates that a Control is invalid, i.e. that an error exists in the input value.
        */
    export const INVALID: string;
    /**
        * Indicates that a Control is pending, i.e. that async validation is occurring and
        * errors are not yet available for the input value.
        */
    export const PENDING: string;
    export function isControl(control: Object): boolean;
    /**
        *
        */
    export abstract class AbstractControl {
            validator: Function;
            asyncValidator: Function;
            constructor(validator: Function, asyncValidator: Function);
            value: any;
            status: string;
            valid: boolean;
            /**
                * Returns the errors of this control.
                */
            errors: {
                    [key: string]: any;
            };
            pristine: boolean;
            dirty: boolean;
            touched: boolean;
            untouched: boolean;
            valueChanges: Observable<any>;
            statusChanges: Observable<any>;
            pending: boolean;
            markAsTouched(): void;
            markAsDirty({onlySelf}?: {
                    onlySelf?: boolean;
            }): void;
            markAsPending({onlySelf}?: {
                    onlySelf?: boolean;
            }): void;
            setParent(parent: ControlGroup | ControlArray): void;
            updateValueAndValidity({onlySelf, emitEvent}?: {
                    onlySelf?: boolean;
                    emitEvent?: boolean;
            }): void;
            /**
                * Sets errors on a control.
                *
                * This is used when validations are run not automatically, but manually by the user.
                *
                * Calling `setErrors` will also update the validity of the parent control.
                *
                * ## Usage
                *
                * ```
                * var login = new Control("someLogin");
                * login.setErrors({
                *   "notUnique": true
                * });
                *
                * expect(login.valid).toEqual(false);
                * expect(login.errors).toEqual({"notUnique": true});
                *
                * login.updateValue("someOtherLogin");
                *
                * expect(login.valid).toEqual(true);
                * ```
                */
            setErrors(errors: {
                    [key: string]: any;
            }, {emitEvent}?: {
                    emitEvent?: boolean;
            }): void;
            find(path: Array<string | number> | string): AbstractControl;
            getError(errorCode: string, path?: string[]): any;
            hasError(errorCode: string, path?: string[]): boolean;
            root: AbstractControl;
    }
    /**
        * Defines a part of a form that cannot be divided into other controls. `Control`s have values and
        * validation state, which is determined by an optional validation function.
        *
        * `Control` is one of the three fundamental building blocks used to define forms in Angular, along
        * with {@link ControlGroup} and {@link ControlArray}.
        *
        * ## Usage
        *
        * By default, a `Control` is created for every `<input>` or other form component.
        * With {@link NgFormControl} or {@link NgFormModel} an existing {@link Control} can be
        * bound to a DOM element instead. This `Control` can be configured with a custom
        * validation function.
        *
        * ### Example ([live demo](http://plnkr.co/edit/23DESOpbNnBpBHZt1BR4?p=preview))
        */
    export class Control extends AbstractControl {
            constructor(value?: any, validator?: Function, asyncValidator?: Function);
            /**
                * Set the value of the control to `value`.
                *
                * If `onlySelf` is `true`, this change will only affect the validation of this `Control`
                * and not its parent component. If `emitEvent` is `true`, this change will cause a
                * `valueChanges` event on the `Control` to be emitted. Both of these options default to
                * `false`.
                *
                * If `emitModelToViewChange` is `true`, the view will be notified about the new value
                * via an `onChange` event. This is the default behavior if `emitModelToViewChange` is not
                * specified.
                */
            updateValue(value: any, {onlySelf, emitEvent, emitModelToViewChange}?: {
                    onlySelf?: boolean;
                    emitEvent?: boolean;
                    emitModelToViewChange?: boolean;
            }): void;
            /**
                * Register a listener for change events.
                */
            registerOnChange(fn: Function): void;
    }
    /**
        * Defines a part of a form, of fixed length, that can contain other controls.
        *
        * A `ControlGroup` aggregates the values and errors of each {@link Control} in the group. Thus, if
        * one of the controls in a group is invalid, the entire group is invalid. Similarly, if a control
        * changes its value, the entire group changes as well.
        *
        * `ControlGroup` is one of the three fundamental building blocks used to define forms in Angular,
        * along with {@link Control} and {@link ControlArray}. {@link ControlArray} can also contain other
        * controls, but is of variable length.
        *
        * ### Example ([live demo](http://plnkr.co/edit/23DESOpbNnBpBHZt1BR4?p=preview))
        */
    export class ControlGroup extends AbstractControl {
            controls: {
                    [key: string]: AbstractControl;
            };
            constructor(controls: {
                    [key: string]: AbstractControl;
            }, optionals?: {
                    [key: string]: boolean;
            }, validator?: Function, asyncValidator?: Function);
            /**
                * Add a control to this group.
                */
            addControl(name: string, control: AbstractControl): void;
            /**
                * Remove a control from this group.
                */
            removeControl(name: string): void;
            /**
                * Mark the named control as non-optional.
                */
            include(controlName: string): void;
            /**
                * Mark the named control as optional.
                */
            exclude(controlName: string): void;
            /**
                * Check whether there is a control with the given name in the group.
                */
            contains(controlName: string): boolean;
    }
    /**
        * Defines a part of a form, of variable length, that can contain other controls.
        *
        * A `ControlArray` aggregates the values and errors of each {@link Control} in the group. Thus, if
        * one of the controls in a group is invalid, the entire group is invalid. Similarly, if a control
        * changes its value, the entire group changes as well.
        *
        * `ControlArray` is one of the three fundamental building blocks used to define forms in Angular,
        * along with {@link Control} and {@link ControlGroup}. {@link ControlGroup} can also contain
        * other controls, but is of fixed length.
        *
        * ## Adding or removing controls
        *
        * To change the controls in the array, use the `push`, `insert`, or `removeAt` methods
        * in `ControlArray` itself. These methods ensure the controls are properly tracked in the
        * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate
        * the `ControlArray` directly, as that will result in strange and unexpected behavior such
        * as broken change detection.
        *
        * ### Example ([live demo](http://plnkr.co/edit/23DESOpbNnBpBHZt1BR4?p=preview))
        */
    export class ControlArray extends AbstractControl {
            controls: AbstractControl[];
            constructor(controls: AbstractControl[], validator?: Function, asyncValidator?: Function);
            /**
                * Get the {@link AbstractControl} at the given `index` in the array.
                */
            at(index: number): AbstractControl;
            /**
                * Insert a new {@link AbstractControl} at the end of the array.
                */
            push(control: AbstractControl): void;
            /**
                * Insert a new {@link AbstractControl} at the given `index` in the array.
                */
            insert(index: number, control: AbstractControl): void;
            /**
                * Remove the control at the given `index` in the array.
                */
            removeAt(index: number): void;
            /**
                * Length of the control array.
                */
            length: number;
    }
}

declare module 'angular2/common/src/common/forms/directives/abstract_control_directive' {
    import { AbstractControl } from 'angular2/common/src/common/forms/model';
    /**
      * Base class for control directives.
      *
      * Only used internally in the forms module.
      */
    export abstract class AbstractControlDirective {
        control: AbstractControl;
        value: any;
        valid: boolean;
        errors: {
            [key: string]: any;
        };
        pristine: boolean;
        dirty: boolean;
        touched: boolean;
        untouched: boolean;
        path: string[];
    }
}

declare module 'angular2/common/src/common/forms/directives/form_interface' {
    import { NgControl } from 'angular2/common/src/common/forms/directives/ng_control';
    import { NgControlGroup } from 'angular2/common/src/common/forms/directives/ng_control_group';
    import { Control, ControlGroup } from 'angular2/common/src/common/forms/model';
    /**
        * An interface that {@link NgFormModel} and {@link NgForm} implement.
        *
        * Only used by the forms module.
        */
    export interface Form {
            /**
                * Add a control to this form.
                */
            addControl(dir: NgControl): void;
            /**
                * Remove a control from this form.
                */
            removeControl(dir: NgControl): void;
            /**
                * Look up the {@link Control} associated with a particular {@link NgControl}.
                */
            getControl(dir: NgControl): Control;
            /**
                * Add a group of controls to this form.
                */
            addControlGroup(dir: NgControlGroup): void;
            /**
                * Remove a group of controls from this form.
                */
            removeControlGroup(dir: NgControlGroup): void;
            /**
                * Look up the {@link ControlGroup} associated with a particular {@link NgControlGroup}.
                */
            getControlGroup(dir: NgControlGroup): ControlGroup;
            /**
                * Update the model for a particular control with a new value.
                */
            updateModel(dir: NgControl, value: any): void;
    }
}

declare module 'angular2/common/src/common/forms/directives/control_container' {
    import { Form } from 'angular2/common/src/common/forms/directives/form_interface';
    import { AbstractControlDirective } from 'angular2/common/src/common/forms/directives/abstract_control_directive';
    /**
        * A directive that contains multiple {@link NgControl}s.
        *
        * Only used by the forms module.
        */
    export class ControlContainer extends AbstractControlDirective {
            name: string;
            /**
                * Get the form to which this container belongs.
                */
            formDirective: Form;
            /**
                * Get the path to this container.
                */
            path: string[];
    }
}

declare module 'angular2/common/src/common/forms/directives/ng_control_name' {
    import { OnChanges, OnDestroy, SimpleChange } from 'angular2/core';
    import { ControlContainer } from 'angular2/common/src/common/forms/directives/control_container';
    import { NgControl } from 'angular2/common/src/common/forms/directives/ng_control';
    import { ControlValueAccessor } from 'angular2/common/src/common/forms/directives/control_value_accessor';
    import { Control } from 'angular2/common/src/common/forms/model';
    /**
      * Creates and binds a control with a specified name to a DOM element.
      *
      * This directive can only be used as a child of {@link NgForm} or {@link NgFormModel}.
    
      * ### Example
      *
      * In this example, we create the login and password controls.
      * We can work with each control separately: check its validity, get its value, listen to its
      * changes.
      *
      *  ```
      * @Component({
      *      selector: "login-comp",
      *      directives: [FORM_DIRECTIVES],
      *      template: `
      *        <form #f="ngForm" (submit)='onLogIn(f.value)'>
      *          Login <input type='text' ngControl='login' #l="form">
      *          <div *ngIf="!l.valid">Login is invalid</div>
      *
      *          Password <input type='password' ngControl='password'>
      *          <button type='submit'>Log in!</button>
      *        </form>
      *      `})
      * class LoginComp {
      *  onLogIn(value): void {
      *    // value === {login: 'some login', password: 'some password'}
      *  }
      * }
      *  ```
      *
      * We can also use ngModel to bind a domain model to the form.
      *
      *  ```
      * @Component({
      *      selector: "login-comp",
      *      directives: [FORM_DIRECTIVES],
      *      template: `
      *        <form (submit)='onLogIn()'>
      *          Login <input type='text' ngControl='login' [(ngModel)]="credentials.login">
      *          Password <input type='password' ngControl='password'
      *                          [(ngModel)]="credentials.password">
      *          <button type='submit'>Log in!</button>
      *        </form>
      *      `})
      * class LoginComp {
      *  credentials: {login:string, password:string};
      *
      *  onLogIn(): void {
      *    // this.credentials.login === "some login"
      *    // this.credentials.password === "some password"
      *  }
      * }
      *  ```
      */
    export class NgControlName extends NgControl implements OnChanges, OnDestroy {
        model: any;
        viewModel: any;
        constructor(_parent: ControlContainer, _validators: any[], _asyncValidators: any[], valueAccessors: ControlValueAccessor[]);
        ngOnChanges(changes: {
            [key: string]: SimpleChange;
        }): void;
        ngOnDestroy(): void;
        viewToModelUpdate(newValue: any): void;
        path: string[];
        formDirective: any;
        validator: Function;
        asyncValidator: Function;
        control: Control;
    }
}

declare module 'angular2/common/src/common/forms/directives/ng_form_control' {
    import { EventEmitter } from 'angular2/src/facade/async';
    import { OnChanges, SimpleChange } from 'angular2/core';
    import { NgControl } from 'angular2/common/src/common/forms/directives/ng_control';
    import { Control } from 'angular2/common/src/common/forms/model';
    import { ControlValueAccessor } from 'angular2/common/src/common/forms/directives/control_value_accessor';
    /**
      * Binds an existing {@link Control} to a DOM element.
      *
      * ### Example ([live demo](http://plnkr.co/edit/jcQlZ2tTh22BZZ2ucNAT?p=preview))
      *
      * In this example, we bind the control to an input element. When the value of the input element
      * changes, the value of the control will reflect that change. Likewise, if the value of the
      * control changes, the input element reflects that change.
      *
      *  ```typescript
      * @Component({
      *   selector: 'my-app',
      *   template: `
      *     <div>
      *       <h2>NgFormControl Example</h2>
      *       <form>
      *         <p>Element with existing control: <input type="text"
      * [ngFormControl]="loginControl"></p>
      *         <p>Value of existing control: {{loginControl.value}}</p>
      *       </form>
      *     </div>
      *   `,
      *   directives: [CORE_DIRECTIVES, FORM_DIRECTIVES]
      * })
      * export class App {
      *   loginControl: Control = new Control('');
      * }
      *  ```
      *
      * ###ngModel
      *
      * We can also use `ngModel` to bind a domain model to the form.
      *
      * ### Example ([live demo](http://plnkr.co/edit/yHMLuHO7DNgT8XvtjTDH?p=preview))
      *
      *  ```typescript
      * @Component({
      *      selector: "login-comp",
      *      directives: [FORM_DIRECTIVES],
      *      template: "<input type='text' [ngFormControl]='loginControl' [(ngModel)]='login'>"
      *      })
      * class LoginComp {
      *  loginControl: Control = new Control('');
      *  login:string;
      * }
      *  ```
      */
    export class NgFormControl extends NgControl implements OnChanges {
        form: Control;
        update: EventEmitter<{}>;
        model: any;
        viewModel: any;
        constructor(_validators: any[], _asyncValidators: any[], valueAccessors: ControlValueAccessor[]);
        ngOnChanges(changes: {
            [key: string]: SimpleChange;
        }): void;
        path: string[];
        validator: Function;
        asyncValidator: Function;
        control: Control;
        viewToModelUpdate(newValue: any): void;
    }
}

declare module 'angular2/common/src/common/forms/directives/ng_model' {
    import { EventEmitter } from 'angular2/src/facade/async';
    import { OnChanges, SimpleChange } from 'angular2/core';
    import { ControlValueAccessor } from 'angular2/common/src/common/forms/directives/control_value_accessor';
    import { NgControl } from 'angular2/common/src/common/forms/directives/ng_control';
    import { Control } from 'angular2/common/src/common/forms/model';
    /**
      * Binds a domain model to a form control.
      *
      * ### Usage
      *
      * `ngModel` binds an existing domain model to a form control. For a
      * two-way binding, use `[(ngModel)]` to ensure the model updates in
      * both directions.
      *
      * ### Example ([live demo](http://plnkr.co/edit/R3UX5qDaUqFO2VYR0UzH?p=preview))
      *  ```typescript
      * @Component({
      *      selector: "search-comp",
      *      directives: [FORM_DIRECTIVES],
      *      template: `<input type='text' [(ngModel)]="searchQuery">`
      *      })
      * class SearchComp {
      *  searchQuery: string;
      * }
      *  ```
      */
    export class NgModel extends NgControl implements OnChanges {
        update: EventEmitter<{}>;
        model: any;
        viewModel: any;
        constructor(_validators: any[], _asyncValidators: any[], valueAccessors: ControlValueAccessor[]);
        ngOnChanges(changes: {
            [key: string]: SimpleChange;
        }): void;
        control: Control;
        path: string[];
        validator: Function;
        asyncValidator: Function;
        viewToModelUpdate(newValue: any): void;
    }
}

declare module 'angular2/common/src/common/forms/directives/ng_control' {
    import { ControlValueAccessor } from 'angular2/common/src/common/forms/directives/control_value_accessor';
    import { AbstractControlDirective } from 'angular2/common/src/common/forms/directives/abstract_control_directive';
    /**
      * A base class that all control directive extend.
      * It binds a {@link Control} object to a DOM element.
      *
      * Used internally by Angular forms.
      */
    export abstract class NgControl extends AbstractControlDirective {
        name: string;
        valueAccessor: ControlValueAccessor;
        validator: Function;
        asyncValidator: Function;
        abstract viewToModelUpdate(newValue: any): void;
    }
}

declare module 'angular2/common/src/common/forms/directives/ng_control_group' {
    import { OnInit, OnDestroy } from 'angular2/core';
    import { ControlContainer } from 'angular2/common/src/common/forms/directives/control_container';
    import { ControlGroup } from 'angular2/common/src/common/forms/model';
    import { Form } from 'angular2/common/src/common/forms/directives/form_interface';
    /**
        * Creates and binds a control group to a DOM element.
        *
        * This directive can only be used as a child of {@link NgForm} or {@link NgFormModel}.
        *
        * ### Example ([live demo](http://plnkr.co/edit/7EJ11uGeaggViYM6T5nq?p=preview))
        *
        * ```typescript
        * @Component({
        *   selector: 'my-app',
        *   directives: [FORM_DIRECTIVES],
        * })
        * @View({
        *   template: `
        *     <div>
        *       <h2>Angular2 Control &amp; ControlGroup Example</h2>
        *       <form #f="ngForm">
        *         <div ngControlGroup="name" #cg-name="form">
        *           <h3>Enter your name:</h3>
        *           <p>First: <input ngControl="first" required></p>
        *           <p>Middle: <input ngControl="middle"></p>
        *           <p>Last: <input ngControl="last" required></p>
        *         </div>
        *         <h3>Name value:</h3>
        *         <pre>{{valueOf(cgName)}}</pre>
        *         <p>Name is {{cgName?.control?.valid ? "valid" : "invalid"}}</p>
        *         <h3>What's your favorite food?</h3>
        *         <p><input ngControl="food"></p>
        *         <h3>Form value</h3>
        *         <pre>{{valueOf(f)}}</pre>
        *       </form>
        *     </div>
        *   `,
        *   directives: [FORM_DIRECTIVES]
        * })
        * export class App {
        *   valueOf(cg: NgControlGroup): string {
        *     if (cg.control == null) {
        *       return null;
        *     }
        *     return JSON.stringify(cg.control.value, null, 2);
        *   }
        * }
        * ```
        *
        * This example declares a control group for a user's name. The value and validation state of
        * this group can be accessed separately from the overall form.
        */
    export class NgControlGroup extends ControlContainer implements OnInit, OnDestroy {
            constructor(parent: ControlContainer, _validators: any[], _asyncValidators: any[]);
            ngOnInit(): void;
            ngOnDestroy(): void;
            /**
                * Get the {@link ControlGroup} backing this binding.
                */
            control: ControlGroup;
            /**
                * Get the path to this control group.
                */
            path: string[];
            /**
                * Get the {@link Form} to which this group belongs.
                */
            formDirective: Form;
            validator: Function;
            asyncValidator: Function;
    }
}

declare module 'angular2/common/src/common/forms/directives/ng_form_model' {
    import { EventEmitter } from 'angular2/src/facade/async';
    import { SimpleChange, OnChanges } from 'angular2/core';
    import { NgControl } from 'angular2/common/src/common/forms/directives/ng_control';
    import { NgControlGroup } from 'angular2/common/src/common/forms/directives/ng_control_group';
    import { ControlContainer } from 'angular2/common/src/common/forms/directives/control_container';
    import { Form } from 'angular2/common/src/common/forms/directives/form_interface';
    import { Control, ControlGroup } from 'angular2/common/src/common/forms/model';
    /**
      * Binds an existing control group to a DOM element.
      *
      * ### Example ([live demo](http://plnkr.co/edit/jqrVirudY8anJxTMUjTP?p=preview))
      *
      * In this example, we bind the control group to the form element, and we bind the login and
      * password controls to the login and password elements.
      *
      *  ```typescript
      * @Component({
      *   selector: 'my-app',
      *   template: `
      *     <div>
      *       <h2>NgFormModel Example</h2>
      *       <form [ngFormModel]="loginForm">
      *         <p>Login: <input type="text" ngControl="login"></p>
      *         <p>Password: <input type="password" ngControl="password"></p>
      *       </form>
      *       <p>Value:</p>
      *       <pre>{{value}}</pre>
      *     </div>
      *   `,
      *   directives: [FORM_DIRECTIVES]
      * })
      * export class App {
      *   loginForm: ControlGroup;
      *
      *   constructor() {
      *     this.loginForm = new ControlGroup({
      *       login: new Control(""),
      *       password: new Control("")
      *     });
      *   }
      *
      *   get value(): string {
      *     return JSON.stringify(this.loginForm.value, null, 2);
      *   }
      * }
      *  ```
      *
      * We can also use ngModel to bind a domain model to the form.
      *
      *  ```typescript
      * @Component({
      *      selector: "login-comp",
      *      directives: [FORM_DIRECTIVES],
      *      template: `
      *        <form [ngFormModel]='loginForm'>
      *          Login <input type='text' ngControl='login' [(ngModel)]='credentials.login'>
      *          Password <input type='password' ngControl='password'
      *                          [(ngModel)]='credentials.password'>
      *          <button (click)="onLogin()">Login</button>
      *        </form>`
      *      })
      * class LoginComp {
      *  credentials: {login: string, password: string};
      *  loginForm: ControlGroup;
      *
      *  constructor() {
      *    this.loginForm = new ControlGroup({
      *      login: new Control(""),
      *      password: new Control("")
      *    });
      *  }
      *
      *  onLogin(): void {
      *    // this.credentials.login === 'some login'
      *    // this.credentials.password === 'some password'
      *  }
      * }
      *  ```
      */
    export class NgFormModel extends ControlContainer implements Form, OnChanges {
        form: ControlGroup;
        directives: NgControl[];
        ngSubmit: EventEmitter<{}>;
        constructor(_validators: any[], _asyncValidators: any[]);
        ngOnChanges(changes: {
            [key: string]: SimpleChange;
        }): void;
        formDirective: Form;
        control: ControlGroup;
        path: string[];
        addControl(dir: NgControl): void;
        getControl(dir: NgControl): Control;
        removeControl(dir: NgControl): void;
        addControlGroup(dir: NgControlGroup): void;
        removeControlGroup(dir: NgControlGroup): void;
        getControlGroup(dir: NgControlGroup): ControlGroup;
        updateModel(dir: NgControl, value: any): void;
        onSubmit(): boolean;
    }
}

declare module 'angular2/common/src/common/forms/directives/ng_form' {
    import { EventEmitter } from 'angular2/src/facade/async';
    import { NgControl } from 'angular2/common/src/common/forms/directives/ng_control';
    import { Form } from 'angular2/common/src/common/forms/directives/form_interface';
    import { NgControlGroup } from 'angular2/common/src/common/forms/directives/ng_control_group';
    import { ControlContainer } from 'angular2/common/src/common/forms/directives/control_container';
    import { AbstractControl, ControlGroup, Control } from 'angular2/common/src/common/forms/model';
    /**
      * If `NgForm` is bound in a component, `<form>` elements in that component will be
      * upgraded to use the Angular form system.
      *
      * ### Typical Use
      *
      * Include `FORM_DIRECTIVES` in the `directives` section of a {@link View} annotation
      * to use `NgForm` and its associated controls.
      *
      * ### Structure
      *
      * An Angular form is a collection of `Control`s in some hierarchy.
      * `Control`s can be at the top level or can be organized in `ControlGroup`s
      * or `ControlArray`s. This hierarchy is reflected in the form's `value`, a
      * JSON object that mirrors the form structure.
      *
      * ### Submission
      *
      * The `ngSubmit` event signals when the user triggers a form submission.
      *
      * ### Example ([live demo](http://plnkr.co/edit/ltdgYj4P0iY64AR71EpL?p=preview))
      *
      *  ```typescript
      * @Component({
      *   selector: 'my-app',
      *   template: `
      *     <div>
      *       <p>Submit the form to see the data object Angular builds</p>
      *       <h2>NgForm demo</h2>
      *       <form #f="ngForm" (ngSubmit)="onSubmit(f.value)">
      *         <h3>Control group: credentials</h3>
      *         <div ngControlGroup="credentials">
      *           <p>Login: <input type="text" ngControl="login"></p>
      *           <p>Password: <input type="password" ngControl="password"></p>
      *         </div>
      *         <h3>Control group: person</h3>
      *         <div ngControlGroup="person">
      *           <p>First name: <input type="text" ngControl="firstName"></p>
      *           <p>Last name: <input type="text" ngControl="lastName"></p>
      *         </div>
      *         <button type="submit">Submit Form</button>
      *       <p>Form data submitted:</p>
      *       </form>
      *       <pre>{{data}}</pre>
      *     </div>
      * `,
      *   directives: [CORE_DIRECTIVES, FORM_DIRECTIVES]
      * })
      * export class App {
      *   constructor() {}
      *
      *   data: string;
      *
      *   onSubmit(data) {
      *     this.data = JSON.stringify(data, null, 2);
      *   }
      * }
      *  ```
      */
    export class NgForm extends ControlContainer implements Form {
        form: ControlGroup;
        ngSubmit: EventEmitter<{}>;
        constructor(validators: any[], asyncValidators: any[]);
        formDirective: Form;
        control: ControlGroup;
        path: string[];
        controls: {
            [key: string]: AbstractControl;
        };
        addControl(dir: NgControl): void;
        getControl(dir: NgControl): Control;
        removeControl(dir: NgControl): void;
        addControlGroup(dir: NgControlGroup): void;
        removeControlGroup(dir: NgControlGroup): void;
        getControlGroup(dir: NgControlGroup): ControlGroup;
        updateModel(dir: NgControl, value: any): void;
        onSubmit(): boolean;
    }
}

declare module 'angular2/common/src/common/forms/directives/control_value_accessor' {
    import { OpaqueToken } from 'angular2/core';
    /**
        * A bridge between a control and a native element.
        *
        * A `ControlValueAccessor` abstracts the operations of writing a new value to a
        * DOM element representing an input control.
        *
        * Please see {@link DefaultValueAccessor} for more information.
        */
    export interface ControlValueAccessor {
            /**
                * Write a new value to the element.
                */
            writeValue(obj: any): void;
            /**
                * Set the function to be called when the control receives a change event.
                */
            registerOnChange(fn: any): void;
            /**
                * Set the function to be called when the control receives a touch event.
                */
            registerOnTouched(fn: any): void;
    }
    /**
        * Used to provide a {@link ControlValueAccessor} for form controls.
        *
        * See {@link DefaultValueAccessor} for how to implement one.
        */
    export const NG_VALUE_ACCESSOR: OpaqueToken;
}

declare module 'angular2/common/src/common/forms/directives/default_value_accessor' {
    import { ElementRef, Renderer } from 'angular2/core';
    import { ControlValueAccessor } from 'angular2/common/src/common/forms/directives/control_value_accessor';
    /**
      * The default accessor for writing a value and listening to changes that is used by the
      * {@link NgModel}, {@link NgFormControl}, and {@link NgControlName} directives.
      *
      *  ### Example
      *  ```
      *  <input type="text" ngControl="searchQuery">
      *  ```
      */
    export class DefaultValueAccessor implements ControlValueAccessor {
        onChange: (_: any) => void;
        onTouched: () => void;
        constructor(_renderer: Renderer, _elementRef: ElementRef);
        writeValue(value: any): void;
        registerOnChange(fn: (_: any) => void): void;
        registerOnTouched(fn: () => void): void;
    }
}

declare module 'angular2/common/src/common/forms/directives/ng_control_status' {
    import { NgControl } from 'angular2/common/src/common/forms/directives/ng_control';
    /**
      * Directive automatically applied to Angular forms that sets CSS classes
      * based on control status (valid/invalid/dirty/etc).
      */
    export class NgControlStatus {
        constructor(cd: NgControl);
        ngClassUntouched: boolean;
        ngClassTouched: boolean;
        ngClassPristine: boolean;
        ngClassDirty: boolean;
        ngClassValid: boolean;
        ngClassInvalid: boolean;
    }
}

declare module 'angular2/common/src/common/forms/directives/checkbox_value_accessor' {
    import { Renderer, ElementRef } from 'angular2/core';
    import { ControlValueAccessor } from 'angular2/common/src/common/forms/directives/control_value_accessor';
    /**
      * The accessor for writing a value and listening to changes on a checkbox input element.
      *
      *  ### Example
      *  ```
      *  <input type="checkbox" ngControl="rememberLogin">
      *  ```
      */
    export class CheckboxControlValueAccessor implements ControlValueAccessor {
        onChange: (_: any) => void;
        onTouched: () => void;
        constructor(_renderer: Renderer, _elementRef: ElementRef);
        writeValue(value: any): void;
        registerOnChange(fn: (_: any) => {}): void;
        registerOnTouched(fn: () => {}): void;
    }
}

declare module 'angular2/common/src/common/forms/directives/select_control_value_accessor' {
    import { Renderer, ElementRef, QueryList } from 'angular2/core';
    import { ControlValueAccessor } from 'angular2/common/src/common/forms/directives/control_value_accessor';
    /**
        * Marks `<option>` as dynamic, so Angular can be notified when options change.
        *
        * ### Example
        *
        * ```
        * <select ngControl="city">
        *   <option *ngFor="#c of cities" [value]="c"></option>
        * </select>
        * ```
        */
    export class NgSelectOption {
    }
    /**
        * The accessor for writing a value and listening to changes on a select element.
        */
    export class SelectControlValueAccessor implements ControlValueAccessor {
            value: string;
            onChange: (_: any) => void;
            onTouched: () => void;
            constructor(_renderer: Renderer, _elementRef: ElementRef, query: QueryList<NgSelectOption>);
            writeValue(value: any): void;
            registerOnChange(fn: () => any): void;
            registerOnTouched(fn: () => any): void;
    }
}

declare module 'angular2/common/src/common/forms/directives' {
    import { Type } from 'angular2/src/facade/lang';
    export { NgControlName } from 'angular2/common/src/common/forms/directives/ng_control_name';
    export { NgFormControl } from 'angular2/common/src/common/forms/directives/ng_form_control';
    export { NgModel } from 'angular2/common/src/common/forms/directives/ng_model';
    export { NgControlGroup } from 'angular2/common/src/common/forms/directives/ng_control_group';
    export { NgFormModel } from 'angular2/common/src/common/forms/directives/ng_form_model';
    export { NgForm } from 'angular2/common/src/common/forms/directives/ng_form';
    export { DefaultValueAccessor } from 'angular2/common/src/common/forms/directives/default_value_accessor';
    export { CheckboxControlValueAccessor } from 'angular2/common/src/common/forms/directives/checkbox_value_accessor';
    export { RadioControlValueAccessor, RadioButtonState } from 'angular2/common/src/common/forms/directives/radio_control_value_accessor';
    export { NumberValueAccessor } from 'angular2/common/src/common/forms/directives/number_value_accessor';
    export { NgControlStatus } from 'angular2/common/src/common/forms/directives/ng_control_status';
    export { SelectControlValueAccessor, NgSelectOption } from 'angular2/common/src/common/forms/directives/select_control_value_accessor';
    export { RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator } from 'angular2/common/src/common/forms/directives/validators';
    export { NgControl } from 'angular2/common/src/common/forms/directives/ng_control';
    export { ControlValueAccessor } from 'angular2/common/src/common/forms/directives/control_value_accessor';
    /**
      *
      * A list of all the form directives used as part of a `@View` annotation.
      *
      *  This is a shorthand for importing them each individually.
      *
      * ### Example
      *
      * ```typescript
      * @Component({
      *   selector: 'my-app',
      *   directives: [FORM_DIRECTIVES]
      * })
      * class MyApp {}
      * ```
      */
    export const FORM_DIRECTIVES: Type[];
}

declare module 'angular2/common/src/common/forms/validators' {
    import { OpaqueToken } from 'angular2/core';
    import * as modelModule from 'angular2/common/src/common/forms/model';
    /**
        * Providers for validators to be used for {@link Control}s in a form.
        *
        * Provide this using `multi: true` to add validators.
        *
        * ### Example
        *
        * {@example core/forms/ts/ng_validators/ng_validators.ts region='ng_validators'}
        */
    export const NG_VALIDATORS: OpaqueToken;
    /**
        * Providers for asynchronous validators to be used for {@link Control}s
        * in a form.
        *
        * Provide this using `multi: true` to add validators.
        *
        * See {@link NG_VALIDATORS} for more details.
        */
    export const NG_ASYNC_VALIDATORS: OpaqueToken;
    /**
        * Provides a set of validators used by form controls.
        *
        * A validator is a function that processes a {@link Control} or collection of
        * controls and returns a map of errors. A null map means that validation has passed.
        *
        * ### Example
        *
        * ```typescript
        * var loginControl = new Control("", Validators.required)
        * ```
        */
    export class Validators {
            /**
                * Validator that requires controls to have a non-empty value.
                */
            static required(control: modelModule.Control): {
                    [key: string]: boolean;
            };
            /**
                * Validator that requires controls to have a value of a minimum length.
                */
            static minLength(minLength: number): Function;
            /**
                * Validator that requires controls to have a value of a maximum length.
                */
            static maxLength(maxLength: number): Function;
            /**
                * Validator that requires a control to match a regex to its value.
                */
            static pattern(pattern: string): Function;
            /**
                * No-op validator.
                */
            static nullValidator(c: any): {
                    [key: string]: boolean;
            };
            /**
                * Compose multiple validators into a single function that returns the union
                * of the individual error maps.
                */
            static compose(validators: Function[]): Function;
            static composeAsync(validators: Function[]): Function;
    }
}

declare module 'angular2/common/src/common/forms/directives/validators' {
    import { Control } from 'angular2/common/src/common/forms/model';
    import * as modelModule from 'angular2/common/src/common/forms/model';
    /**
        * An interface that can be implemented by classes that can act as validators.
        *
        * ## Usage
        *
        * ```typescript
        * @Directive({
        *   selector: '[custom-validator]',
        *   providers: [provide(NG_VALIDATORS, {useExisting: CustomValidatorDirective, multi: true})]
        * })
        * class CustomValidatorDirective implements Validator {
        *   validate(c: Control): {[key: string]: any} {
        *     return {"custom": true};
        *   }
        * }
        * ```
        */
    export interface Validator {
            validate(c: modelModule.Control): {
                    [key: string]: any;
            };
    }
    /**
        * A Directive that adds the `required` validator to any controls marked with the
        * `required` attribute, via the {@link NG_VALIDATORS} binding.
        *
        * ### Example
        *
        * ```
        * <input ngControl="fullName" required>
        * ```
        */
    export class RequiredValidator {
    }
    /**
        * A directive which installs the {@link MinLengthValidator} for any `ngControl`,
        * `ngFormControl`, or control with `ngModel` that also has a `minlength` attribute.
        */
    export class MinLengthValidator implements Validator {
            constructor(minLength: string);
            validate(c: Control): {
                    [key: string]: any;
            };
    }
    /**
        * A directive which installs the {@link MaxLengthValidator} for any `ngControl, `ngFormControl`,
        * or control with `ngModel` that also has a `maxlength` attribute.
        */
    export class MaxLengthValidator implements Validator {
            constructor(maxLength: string);
            validate(c: Control): {
                    [key: string]: any;
            };
    }
    export class PatternValidator implements Validator {
            constructor(pattern: string);
            validate(c: Control): {
                    [key: string]: any;
            };
    }
}

declare module 'angular2/common/src/common/forms/form_builder' {
    import * as modelModule from 'angular2/common/src/common/forms/model';
    /**
        * Creates a form object from a user-specified configuration.
        *
        * ### Example ([live demo](http://plnkr.co/edit/ENgZo8EuIECZNensZCVr?p=preview))
        *
        * ```typescript
        * @Component({
        *   selector: 'my-app',
        *   viewBindings: [FORM_BINDINGS]
        *   template: `
        *     <form [ngFormModel]="loginForm">
        *       <p>Login <input ngControl="login"></p>
        *       <div ngControlGroup="passwordRetry">
        *         <p>Password <input type="password" ngControl="password"></p>
        *         <p>Confirm password <input type="password" ngControl="passwordConfirmation"></p>
        *       </div>
        *     </form>
        *     <h3>Form value:</h3>
        *     <pre>{{value}}</pre>
        *   `,
        *   directives: [FORM_DIRECTIVES]
        * })
        * export class App {
        *   loginForm: ControlGroup;
        *
        *   constructor(builder: FormBuilder) {
        *     this.loginForm = builder.group({
        *       login: ["", Validators.required],
        *       passwordRetry: builder.group({
        *         password: ["", Validators.required],
        *         passwordConfirmation: ["", Validators.required, asyncValidator]
        *       })
        *     });
        *   }
        *
        *   get value(): string {
        *     return JSON.stringify(this.loginForm.value, null, 2);
        *   }
        * }
        * ```
        */
    export class FormBuilder {
            /**
                * Construct a new {@link ControlGroup} with the given map of configuration.
                * Valid keys for the `extra` parameter map are `optionals` and `validator`.
                *
                * See the {@link ControlGroup} constructor for more details.
                */
            group(controlsConfig: {
                    [key: string]: any;
            }, extra?: {
                    [key: string]: any;
            }): modelModule.ControlGroup;
            /**
                * Construct a new {@link Control} with the given `value`,`validator`, and `asyncValidator`.
                */
            control(value: Object, validator?: Function, asyncValidator?: Function): modelModule.Control;
            /**
                * Construct an array of {@link Control}s from the given `controlsConfig` array of
                * configuration, with the given optional `validator` and `asyncValidator`.
                */
            array(controlsConfig: any[], validator?: Function, asyncValidator?: Function): modelModule.ControlArray;
    }
}

declare module 'angular2/common/src/common/forms/directives/radio_control_value_accessor' {
    import { ElementRef, Renderer, OnInit, OnDestroy, Injector } from 'angular2/core';
    import { ControlValueAccessor } from 'angular2/src/common/forms/directives/control_value_accessor';
    import { NgControl } from 'angular2/src/common/forms/directives/ng_control';
    /**
        * Internal class used by Angular to uncheck radio buttons with the matching name.
        */
    export class RadioControlRegistry {
            add(control: NgControl, accessor: RadioControlValueAccessor): void;
            remove(accessor: RadioControlValueAccessor): void;
            select(accessor: RadioControlValueAccessor): void;
    }
    /**
        * The value provided by the forms API for radio buttons.
        */
    export class RadioButtonState {
            checked: boolean;
            value: string;
            constructor(checked: boolean, value: string);
    }
    /**
        * The accessor for writing a radio control value and listening to changes that is used by the
        * {@link NgModel}, {@link NgFormControl}, and {@link NgControlName} directives.
        *
        *  ### Example
        *  ```
        *  @Component({
        *    template: `
        *      <input type="radio" name="food" [(ngModel)]="foodChicken">
        *      <input type="radio" name="food" [(ngModel)]="foodFish">
        *    `
        *  })
        *  class FoodCmp {
        *    foodChicken = new RadioButtonState(true, "chicken");
        *    foodFish = new RadioButtonState(false, "fish");
        *  }
        *  ```
        */
    export class RadioControlValueAccessor implements ControlValueAccessor, OnDestroy, OnInit {
            _state: RadioButtonState;
            _control: NgControl;
            name: string;
            _fn: Function;
            onChange: () => void;
            onTouched: () => void;
            constructor(_renderer: Renderer, _elementRef: ElementRef, _registry: RadioControlRegistry, _injector: Injector);
            ngOnInit(): void;
            ngOnDestroy(): void;
            writeValue(value: any): void;
            registerOnChange(fn: (_: any) => {}): void;
            fireUncheck(): void;
            registerOnTouched(fn: () => {}): void;
    }
}

declare module 'angular2/common/src/common/forms/directives/number_value_accessor' {
    import { ElementRef, Renderer } from 'angular2/core';
    import { ControlValueAccessor } from 'angular2/common/src/common/forms/directives/control_value_accessor';
    /**
      * The accessor for writing a number value and listening to changes that is used by the
      * {@link NgModel}, {@link NgFormControl}, and {@link NgControlName} directives.
      *
      *  ### Example
      *  ```
      *  <input type="number" [(ngModel)]="age">
      *  ```
      */
    export class NumberValueAccessor implements ControlValueAccessor {
        onChange: (_: any) => void;
        onTouched: () => void;
        constructor(_renderer: Renderer, _elementRef: ElementRef);
        writeValue(value: number): void;
        registerOnChange(fn: (_: number) => void): void;
        registerOnTouched(fn: () => void): void;
    }
}

